%!PS-Adobe-2.0
%%Creator: dvips(k) 5.999 Copyright 2019 Radical Eye Software
%%Title: CorrigesTechno.dvi
%%CreationDate: Mon Jul 10 11:45:08 2023
%%Pages: 2
%%PageOrder: Ascend
%%BoundingBox: 0 0 612 792
%%DocumentFonts: Utopia-Regular Utopia-Bold Fourier-Math-Symbols
%%+ Fourier-Math-Letters-Italic
%%DocumentPaperSizes: Letter
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: /usr/bin/dvips -o CorrigesTechno.ps
%+ CorrigesTechno.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2023.07.10:1345
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 872 2018-12-21 20:39:31Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.30, 2018/12/17
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/Power { %  a^b   latest ghostscript don't allow -4^-3.1
  2 dict begin	% hold all local
  /b ED
  /a ED
  a 0 lt % prevent something like (-4)^(-3.1)=> 1/(-4)^3
    { b 0 lt 
      { a b cvi exp }
      { a b exp } ifelse 
    }
    { a 0 eq { 0 }{ a b exp } ifelse
    } ifelse
  end
} def
%
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian (origimal)
/PtoCrel { pst@angleunit PtoC } def % Polar to Cartesian with \degrees[??]
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
/AnytoDeg { pst@angleunit } def 
/DegtoAny { 1 pst@angleunit div} def
/AnytoRad { AnytoDeg DegtoRad } def 
/RadtoAny { RadtoDeg DegtoAny } def
%
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
%  x1 y2 lineto 
%  x2 y2 lineto 
%  x2 y1 lineto
%  x1 y1 lineto 
  x1 y1 lineto  % counter clockwise path
  x2 y1 lineto 
  x2 y2 lineto
  x1 y2 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Helvetica findfont b scalefont setfont 
%    is set in pstricks.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
%     /NimbusSanL-Regu findfont b scalefont setfont   
  /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup xGridOffset add y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup yGridOffset add x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 446 2017-04-19 11:40:55Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.06, 2017/12/03
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/concatstrings{ % (a) (b) -> (ab)  
  1 dict begin
  exch dup length    
  2 index length add string    
  dup dup 4 2 roll copy length
  4 -1 roll putinterval
  end
} def
%
/reversestring { % (aBC) -> (CBa)
  5 dict begin
  /str exch def
  /L str length def
  /strTemp L string def
  /i 0 def
  L { 
    /I L 1 sub i sub def
    strTemp i str I 1 getinterval putinterval
    /i i 1 add def
  } repeat
  strTemp
  end
} def
%
/concatarray{ % [a c] [b d] -> [a c b d]  
  2 dict begin
  /a2 exch def
  /a1 exch def
  [ a1 aload pop a2 aload pop ]
  end
} def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 446 2017-04-19 11:40:55Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 395 2017-03-21 09:24:38Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not alowed!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2018/12/16 $
% Version         : 0.65 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% $Id: pst-text.pro 891 2018-12-29 19:42:20Z herbert $
%
% PostScript header file pst-text.pro
% Version 1.02, 2018-12-28 (hv)
% For distribution, see pstricks.tex.
%
/tx@TextPathDict 45 dict def
tx@TextPathDict begin
%
% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def
%
/movetoproc { continue { @movetoproc } { pop pop } ifelse } def
%
/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def
%
/linetoproc { continue { @linetoproc } { pop pop } ifelse } def
%
/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def
%
/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def
%
% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def
%
/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def
%
/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def
%
%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint
    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
/warp {
    1 index
    1.4 mul
    cos 2 add
    mul
} def
/warpmove{
    2 index {
        newpath
    } if
    warp moveto
    pop false
} def
/warpline { warp lineto } def
/warpcurve {
    6 2 roll warp
    6 2 roll warp
    6 2 roll warp
    curveto
} def
/warpit {
    true
    { warpmove } { warpline } { warpcurve } { closepath } pathforall
    pop
} def
%
/circle {
    exch neg
    % .5 mul
    90 add
    dup cos 2 index mul
    3 1 roll
    sin mul
} bind def

/circmove{
    2 index { newpath } if
    circle moveto
    pop false
} bind def

/circline { circle lineto } bind def

/circcurve {
    6 2 roll circle
    6 2 roll circle
    6 2 roll circle
    curveto
} bind def

/circit { true { circmove } { circline } { circcurve } { closepath } pathforall pop } bind def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: l3backend-dvips.pro 0 0
%%
%% This is file `l3backend-dvips.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% l3backend-header.dtx  (with options: `header,dvips')
%% 
%% Copyright (C) 1990-2020 The LaTeX3 Project
%% 
%% It may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License (LPPL), either version 1.3c of
%% this license or (at your option) any later version.  The latest
%% version of this license is in the file:
%% 
%%    https://www.latex-project.org/lppl.txt
%% 
%% This file is part of the "l3backend bundle" (The Work in LPPL)
%% and all files in that bundle must be distributed together.
%% 
%% File: l3backend-header.dtx
true setglobal
/pdf.globaldict 4 dict def
false setglobal

/pdf.cvs { 65534 string cvs } def
/pdf.dvi.pt { 72.27 mul Resolution div } def
/pdf.pt.dvi { 72.27 div Resolution mul } def
/pdf.rect.ht { dup 1 get neg exch 3 get add } def
/pdf.linkmargin { 1 pdf.pt.dvi } def
/pdf.linkdp.pad { 0 } def
/pdf.linkht.pad { 0 } def
/pdf.rect
  { /Rect [ pdf.llx pdf.lly pdf.urx pdf.ury ] } def
/pdf.save.ll
  {
    currentpoint
    /pdf.lly exch def
    /pdf.llx exch def
  }
    def
/pdf.save.ur
  {
    currentpoint
    /pdf.ury exch def
    /pdf.urx exch def
  }
    def
/pdf.save.linkll
  {
    currentpoint
    pdf.linkmargin add
    pdf.linkdp.pad add
    /pdf.lly exch def
    pdf.linkmargin sub
    /pdf.llx exch def
  }
    def
/pdf.save.linkur
  {
    currentpoint
    pdf.linkmargin sub
    pdf.linkht.pad sub
    /pdf.ury exch def
    pdf.linkmargin add
    /pdf.urx exch def
  }
    def
/pdf.dest.anchor
  {
    currentpoint exch
    pdf.dvi.pt 72 add
    /pdf.dest.x exch def
    pdf.dvi.pt
    vsize 72 sub exch sub
    /pdf.dest.y exch def
  }
    def
/pdf.dest.point
  { pdf.dest.x pdf.dest.y } def
/pdf.dest2device
  {
    /pdf.dest.y exch def
    /pdf.dest.x exch def
    matrix currentmatrix
    matrix defaultmatrix
    matrix invertmatrix
    matrix concatmatrix
    cvx exec
    /pdf.dev.y exch def
    /pdf.dev.x exch def
    /pdf.tmpd exch def
    /pdf.tmpc exch def
    /pdf.tmpb exch def
    /pdf.tmpa exch def
    pdf.dest.x pdf.tmpa mul
      pdf.dest.y pdf.tmpc mul add
      pdf.dev.x add
    pdf.dest.x pdf.tmpb mul
     pdf.dest.y pdf.tmpd mul add
     pdf.dev.y add
  }
    def
/pdf.bordertracking false def
/pdf.bordertracking.begin
  {
    SDict /pdf.bordertracking true put
    SDict /pdf.leftboundary undef
    SDict /pdf.rightboundary undef
    /a where
      {
        /a
          {
            currentpoint pop
            SDict /pdf.rightboundary known dup
              {
                SDict /pdf.rightboundary get 2 index lt
                  { not }
                if
              }
            if
              { pop }
              { SDict exch /pdf.rightboundary exch put }
            ifelse
            moveto
            currentpoint pop
            SDict /pdf.leftboundary known dup
              {
                SDict /pdf.leftboundary get 2 index gt
                  { not }
                if
              }
            if
              { pop }
              { SDict exch /pdf.leftboundary exch put }
            ifelse
          }
        put
      }
    if
  }
    def
/pdf.bordertracking.end
  {
    /a where { /a { moveto } put } if
    /x where { /x { 0 exch rmoveto } put } if
    SDict /pdf.leftboundary known
      { pdf.outerbox 0 pdf.leftboundary put }
    if
    SDict /pdf.rightboundary known
      { pdf.outerbox 2 pdf.rightboundary put }
    if
    SDict /pdf.bordertracking false put
  }
    def
  /pdf.bordertracking.endpage
{
  pdf.bordertracking
    {
      pdf.bordertracking.end
      true setglobal
      pdf.globaldict
        /pdf.brokenlink.rect [ pdf.outerbox aload pop ] put
      pdf.globaldict
        /pdf.brokenlink.skip pdf.baselineskip put
      pdf.globaldict
        /pdf.brokenlink.dict
          pdf.link.dict pdf.cvs put
      false setglobal
      mark pdf.link.dict cvx exec /Rect
        [
          pdf.llx
          pdf.lly
          pdf.outerbox 2 get pdf.linkmargin add
          currentpoint exch pop
          pdf.outerbox pdf.rect.ht sub pdf.linkmargin sub
        ]
      /ANN pdf.pdfmark
    }
  if
}
  def
/pdf.bordertracking.continue
  {
    /pdf.link.dict pdf.globaldict
      /pdf.brokenlink.dict get def
    /pdf.outerbox pdf.globaldict
      /pdf.brokenlink.rect get def
    /pdf.baselineskip pdf.globaldict
      /pdf.brokenlink.skip get def
    pdf.globaldict dup dup
    /pdf.brokenlink.dict undef
    /pdf.brokenlink.skip undef
    /pdf.brokenlink.rect undef
    currentpoint
    /pdf.originy exch def
    /pdf.originx exch def
    /a where
      {
        /a
          {
            moveto
            SDict
            begin
            currentpoint pdf.originy ne exch
              pdf.originx ne or
              {
                pdf.save.linkll
                /pdf.lly
                  pdf.lly pdf.outerbox 1 get sub def
                pdf.bordertracking.begin
              }
            if
            end
          }
        put
      }
    if
    /x where
      {
        /x
          {
            0 exch rmoveto
            SDict~
            begin
            currentpoint
            pdf.originy ne exch pdf.originx ne or
              {
                pdf.save.linkll
                /pdf.lly
                  pdf.lly pdf.outerbox 1 get sub def
                pdf.bordertracking.begin
              }
            if
            end
          }
        put
      }
    if
  }
    def
/pdf.breaklink
  {
    pop
    counttomark 2 mod 0 eq
      {
        counttomark /pdf.count exch def
          {
           pdf.count 0 eq { exit } if
           counttomark 2 roll
           1 index /Rect eq
             {
               dup 4 array copy
               dup dup
                 1 get
                 pdf.outerbox pdf.rect.ht
                 pdf.linkmargin 2 mul add sub
                 3 exch put
               dup
                 pdf.outerbox 2 get
                 pdf.linkmargin add
                 2 exch put
               dup dup
                 3 get
                 pdf.outerbox pdf.rect.ht
                 pdf.linkmargin 2 mul add add
                 1 exch put
               /pdf.currentrect exch  def
               pdf.breaklink.write
                 {
                   pdf.currentrect
                   dup
                     pdf.outerbox 0 get
                     pdf.linkmargin sub
                     0 exch put
                   dup
                     pdf.outerbox 2 get
                     pdf.linkmargin add
                     2 exch put
                   dup dup
                     1 get
                     pdf.baselineskip add
                     1 exch put
                   dup dup
                     3 get
                     pdf.baselineskip add
                     3 exch put
                   /pdf.currentrect exch def
                   pdf.breaklink.write
                  }
                1 index 3 get
                pdf.linkmargin 2 mul add
                pdf.outerbox pdf.rect.ht add
                2 index 1 get sub
                pdf.baselineskip div round cvi 1 sub
                exch
              repeat
              pdf.currentrect
              dup
                pdf.outerbox 0 get
                pdf.linkmargin sub
                0 exch put
              dup dup
                1 get
                pdf.baselineskip add
                1 exch put
              dup dup
                3 get
                pdf.baselineskip add
                3 exch put
              dup 2 index 2 get  2 exch put
              /pdf.currentrect exch def
              pdf.breaklink.write
              SDict /pdf.pdfmark.good false put
              exit
            }
            { pdf.count 2 sub /pdf.count exch def }
          ifelse
        }
      loop
    }
  if
  /ANN
}
  def
/pdf.breaklink.write
  {
    counttomark 1 sub
    index /_objdef eq
      {
        counttomark -2 roll
        dup wcheck
          {
            readonly
            counttomark 2 roll
          }
          { pop pop }
        ifelse
      }
    if
    counttomark 1 add copy
    pop pdf.currentrect
    /ANN pdfmark
  }
    def
/pdf.pdfmark
  {
    SDict /pdf.pdfmark.good true put
    dup /ANN eq
      {
        pdf.pdfmark.store
        pdf.pdfmark.dict
          begin
            Subtype /Link eq
            currentdict /Rect known and
            SDict /pdf.outerbox known and
            SDict /pdf.baselineskip known and
              {
                Rect 3 get
                pdf.linkmargin 2 mul add
                pdf.outerbox pdf.rect.ht add
                Rect 1 get sub
                pdf.baselineskip div round cvi 0 gt
                  { pdf.breaklink }
                if
              }
            if
          end
        SDict /pdf.outerbox undef
        SDict /pdf.baselineskip undef
        currentdict /pdf.pdfmark.dict undef
      }
    if
    pdf.pdfmark.good
      { pdfmark }
      { cleartomark }
    ifelse
  }
    def
/pdf.pdfmark.store
  {
    /pdf.pdfmark.dict 65534 dict def
    counttomark 1 add copy
    pop
      {
        dup mark eq
          {
            pop
            exit
          }
          {
            pdf.pdfmark.dict
            begin def end
          }
        ifelse
      }
    loop
}
  def
%% 
%%
%% End of file `l3backend-dvips.pro'.

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pgfHrgb{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfArgb} def /pgfdir { dup 0 moveto dup 5 index lineto } bind def}
bind def

 /pgfVrgb{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfArgb} def /pgfdir { dup 0 exch moveto dup 5 index exch lineto }
bind def} bind def

 /pgfArgb{ /pgfdiff 8 index round cvi 8 index round cvi sub 2 mul 1
add def 2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff
div 2 index 6 index sub pgfdiff div pgfheight 9 index 9 index 9 index
14 index pgfdiff { 3 index 3 index 3 index setrgbcolor pgfdir stroke
4 -1 roll 7 index add 4 -1 roll 6 index add 4 -1 roll 5 index add 4
-1 roll .5 sub } repeat mark 15 1 roll cleartomark exch pop }bind def

 /pgfR1rgb{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx
exch def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade
{pgfRrgb} def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx
pgfstartx sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb
exch def }bind def

 /pgfR2rgb{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setrgbcolor
fill pop}bind def

 /pgfRrgb{ /pgfdiff 8 index round cvi 8 index round cvi sub 4 mul 1
add def /pgfcircx pgfstartx 9 index pgfdiffx pgfdomb div mul add def
/pgfcircy pgfstarty 9 index pgfdiffy pgfdomb div mul add def /pgfcircxe
pgfstartx 8 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty
8 index pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx
sub pgfdiff div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def
2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff div 2 index
6 index sub pgfdiff div 8 index 8 index 8 index 13 index pgfdiff {
3 index 3 index 3 index setrgbcolor pgfcircx pgfcircy 2 index 0 360
arc closepath stroke 4 -1 roll 6 index add 4 -1 roll 5 index add 4
-1 roll 4 index add 4 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep add
def /pgfcircy pgfcircy pgfystep add def } repeat mark 14 1 roll cleartomark
exch pop }bind def

 /pgfHcmyk{ /pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfAcmyk} def /pgfdir { dup 0 moveto dup 6 index lineto } bind def}
bind def

 /pgfVcmyk{ /pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfAcmyk} def /pgfdir { dup 0 exch moveto dup 6 index exch lineto
} bind def} bind def

 /pgfAcmyk{ /pgfdiff 10 index round cvi 10 index round cvi sub 2 mul
1 add def 3 index 8 index sub pgfdiff div 3 index 8 index sub pgfdiff
div 3 index 8 index sub pgfdiff div 3 index 8 index sub pgfdiff div
pgfheight 12 index 12 index 12 index 12 index 18 index pgfdiff { 4
index 4 index 4 index 4 index setcmykcolor pgfdir stroke 5 -1 roll
9 index add 5 -1 roll 8 index add 5 -1 roll 7 index add 5 -1 roll 6
index add 5 -1 roll .5 sub } repeat mark 19 1 roll cleartomark exch
pop }bind def

 /pgfR1cmyk{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx
exch def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade
{pgfRcmyk} def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx
pgfstartx sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb
exch def }bind def

 /pgfR2cmyk{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setcmykcolor
fill pop}bind def

 /pgfRcmyk{ /pgfdiff 10 index round cvi 10 index round cvi sub 4 mul
1 add def /pgfcircx pgfstartx 11 index pgfdiffx pgfdomb div mul add
def /pgfcircy pgfstarty 11 index pgfdiffy pgfdomb div mul add def /pgfcircxe
pgfstartx 10 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty
10 index pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx
sub pgfdiff div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def
3 index 8 index sub pgfdiff div 3 index 8 index sub pgfdiff div 3 index
8 index sub pgfdiff div 3 index 8 index sub pgfdiff div 11 index 11
index 11 index 11 index 17 index pgfdiff { 4 index 4 index 4 index
4 index setcmykcolor pgfcircx pgfcircy 2 index 0 360 arc closepath
stroke 5 -1 roll 8 index add 5 -1 roll 7 index add 5 -1 roll 6 index
add 5 -1 roll 5 index add 5 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep
add def /pgfcircy pgfcircy pgfystep add def } repeat mark 18 1 roll
cleartomark exch pop }bind def

 /pgfHgray{ /pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfAgray} def /pgfdir { dup 0 moveto dup 3 index lineto } bind def}
bind def

 /pgfVgray{ /pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfAgray} def /pgfdir { dup 0 exch moveto dup 3 index exch lineto
} bind def} bind def

 /pgfAgray{ /pgfdiff 4 index round cvi 4 index round cvi sub 2 mul
1 add def dup 2 index sub pgfdiff div pgfheight 3 index 6 index pgfdiff
{ 1 index setgray pgfdir stroke exch 3 index add exch .5 sub } repeat
mark 7 1 roll cleartomark exch pop }bind def

 /pgfR1gray{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx
exch def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade
{pgfRgray} def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx
pgfstartx sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb
exch def }bind def

 /pgfR2gray{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setgray
fill pop}bind def

 /pgfRgray{ /pgfdiff 4 index round cvi 4 index round cvi sub 4 mul
1 add def /pgfcircx pgfstartx 5 index pgfdiffx pgfdomb div mul add
def /pgfcircy pgfstarty 5 index pgfdiffy pgfdomb div mul add def /pgfcircxe
pgfstartx 4 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty
4 index pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx
sub pgfdiff div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def
dup 2 index sub pgfdiff div 2 index 5 index pgfdiff { 1 index setgray
pgfcircx pgfcircy 2 index 0 360 arc closepath stroke exch 2 index add
exch .25 sub /pgfcircx pgfcircx pgfxstep add def /pgfcircy pgfcircy
pgfystep add def } repeat mark 6 1 roll cleartomark exch pop }bind
def

  /pgfsc{}bind def/pgffc{}bind def/pgfstr{stroke}bind def/pgffill{fill}bind
def/pgfeofill{eofill}bind def/pgfe{a dup 0 rlineto exch 0 exch rlineto
neg 0 rlineto closepath}bind def/pgfw{setlinewidth}bind def/pgfs{save
pgfpd 72 Resolution div 72 VResolution div neg scale magscale{1 DVImag
div dup scale}if pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind
def/pgfr{pgfsd restore}bind def userdict begin/pgfo{pgfsd /pgfx currentpoint
/pgfy exch def def @beginspecial}bind def /pgfc{newpath @endspecial
pgfpd}bind def /pgfsd{globaldict /pgfdelta /delta where {pop delta}
{0} ifelse put}bind def/pgfpd{/delta globaldict /pgfdelta get def}bind
def /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse
/.pgfsetfillopacityalpha{/pgffoa exch def /pgffill{gsave pgffoa .setopacityalpha
fill 1 .setopacityalpha newpath fill grestore newpath}bind def /pgfeofill{gsave
pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore
newpath}bind def}bind def /.pgfsetstrokeopacityalpha{/pgfsoa exch def
/pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind
def}bind def /pgffoa 1 def /pgfsoa 1 def end

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def product (Ghostscript)
search {pop pop pop revision 927 gt}{pop false} ifelse{/BorderArrayPatch{}
def}{/BorderArrayPatch{[exch{dup dup type/integertype eq exch type/realtype
eq or{BPToDvips}if}forall]}def} ifelse /HyperBorder {1 PDFToDvips}
def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx pdf@lly pdf@urx
pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly exch def dup
DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx exch
def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def

 /pgf1{gsave exec 1.0 pgfw 2.00002 0.0 moveto -6.00006 4.00005 lineto
-3.00003 0.0 lineto -6.00006 -4.00005 lineto pgffill  grestore} bind
def

 /pgf2{gsave exec 1.0 pgfw 0.8 pgfw [ ] 0.0 setdash 1 setlinecap 1
setlinejoin -3.00003 4.00005 moveto -2.75002 2.50002 0.0 0.24998 0.75
0.0 curveto 0.0 -0.24998 -2.75002 -2.50002 -3.00003 -4.00005 curveto
pgfstr  grestore} bind def

 /pgf3{gsave exec 1.0 pgfw [ ] 0.0 setdash 0.0 -5.00005 moveto 0.0
5.00005 lineto pgfstr  grestore} bind def

 /pgf4{gsave exec 1.0 pgfw [ ] 0.0 setdash -3.00003 -5.00005 moveto
0.0 -5.00005 lineto 0.0 5.00005 lineto -3.00003 5.00005 lineto pgfstr
 grestore} bind def

 /pgf5{gsave exec 1.0 pgfw [ ] 0.0 setdash -2.00002 -5.00005 moveto
1.0 -3.00003 1.0 3.00003 -2.00002 5.00005 curveto pgfstr  grestore}
bind def

 /pgf6{gsave exec 1.0 pgfw [ ] 0.0 setdash -4.50003 -5.00005 moveto
0.49998 0.0 lineto -4.50003 5.00005 lineto pgfstr  grestore} bind def

 /pgf7{gsave exec 1.0 pgfw -2.50002 0.0 translate [ ] 0.0 setdash 3.00003
0.0 moveto 3.00003 1.65689 1.65689 3.00003 0.0 3.00003 curveto -1.65689
3.00003 -3.00003 1.65689 -3.00003 0.0 curveto -3.00003 -1.65689 -1.65689
-3.00003 0.0 -3.00003 curveto 1.65689 -3.00003 3.00003 -1.65689 3.00003
0.0 curveto closepath gsave pgffc pgffill grestore gsave pgfsc pgfstr
grestore newpath  grestore} bind def

 /pgf8{gsave exec 1.0 pgfw [ ] 0.0 setdash 1.0 0.0 moveto -5.00005
3.00003 lineto -11.00012 0.0 lineto -5.00005 -3.00003 lineto closepath
gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore newpath  grestore}
bind def
 
@fedspecial end
%%BeginFont: Fourier-Math-Symbols
%!PS-AdobeFont-1.0: Fourier-Math-Symbols 001.004
%%CreationDate: Fri Jan 7 18:50:41 2005
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice (Copyright 2003-2004, GUTenberg) readonly def
/FullName (Fourier-Math-Symbols) readonly def
/FamilyName (Fourier-Math-Symbols) readonly def
/ItalicAngle -15 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Regular) readonly def
end readonly def
/FontName /Fourier-Math-Symbols def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 163 /multiply put
dup 165 /divide put
dup 188 /approxequal put
dup 198 /equal put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-34 -960 1001 847} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D441AB
0467A1BF50AD0DE4F98225ADD1F93634005664EC4D3A79AAE931F7496D4AD122
EAEBCBFB4D4AC1B8D85E9CBE4ABB2225405A9DA5AB44E12A710451885D4FADD8
C3F48A838573A733544D6AD3B5C7B3E16F8F777F1DD842F33638F7D57C0C9212
0C6560A06445FFE43730EC1895E85874440C56BF079DCF6C249978AEC565369E
E2DE0A62595334A70543753553A4D58895F84C9627524042C4B480C4654D6578
67B2C0CC4A43523BABBF2E8BB693003339A7DD77148E4C146BF5A7AA602A3908
5300B7C1798206E16AAEC1262E3B1DD7325659679A19229F75B0A7BF816E1594
68BE15C3F762C51595E7902AAB117057F4EB1316DC1C507B857AC1B1BE38123E
4AB0CC69F0C42D92081FEAC1259E24E696131A9170053DED6CE28A4D407AE241
675620191E5953CB96967BF04CE1DCB7B9089849FE477F73ADDA94B72632B5C3
E4B12701C044D3B666DB24E45DF8FB89C5DA53188D7C588C1F9DCE353F3D357C
212D5E0CE43B242313912CB809EA23E8158049754D5A9129419949A7C79BB1C5
17FD49A1E5FC3A4095D91E472B31D7A788DB3D0D0778C6D96F68C849FD58496A
9F820DA8C2E98BA0DB5D0EDD60D0A5EF062D122D5B440DEEF97172CA0DA38AC6
D8AE16E16E62C3A99D3B1DF9F1BEA90163879CEA5BA341CB947DFB0C41B08B06
946F9C8A754B9FD193F9EB60CF81B8343A759E5D9641BCE58C2D8C0BF5CBB461
88E32829BBBEEF6E1C8A713A3A614565A4A9AFDD566D081CE2954D486E275D41
3BB9DCEF1E66E7EC178E370757EC626E6E82D294BF3E83ECC0782DC63E319DD4
CF867F340449A0A245430C101F3E5DB92CD828ECD21A2B602F26E72FEB38368F
DC03123FA421EEA747607B26A3030C048BD160A39735FB6B8836B8B5A4D2AA84
96C5E265C58458246B1452B308A022655587FDF933817766BE8A1E6C29DC4365
DC1ED202CBD81E0339EC4C3C57B054EADA2C699385B3CD763CA06787E96684BF
86F7BBA7009447D8D50167498735295CFFA5358D068EA503BEBC2D3A7EEDE760
BBC03394A6B01B1AEC021C9F06834D1CDE5DED19A5A1F909707C0AA8E88898CF
1946FEBADD822804C3319B8F8FC6EB7CE96C596A8883E67BE54CB8FBE9AE9AD8
6165178CC031B3D1DD0097E80122D38E061601D78E106AC6FCD4E63C37A46924
E6D0C55C32045198397AF3B6747F4526427F8D5CE67A2FE296BCD263C5270898
62BB6871E51A44019D917A6E9E2ADD7C22D919B253946AD5B40875196296ADF7
B3EA4C9E940DCEE809650E9CEE1C226C215D5825E4A9FACCCC354D6996DBA8CC
7EFDD3FEDC1E84E2C9D9BAED3C98AE4AE25F5A21A5904AC7D0DFFBBAF61B24CF
781C6711806A527304A1C42F191B06BAD8D668BB517A7D6DB9D7D1AADE6013A1
42F9F77BED68BDE5FF1A471FD907FF17608910F322F2CD984688D715C1C4121F
7ED77460F79D9952E39ACFF2A2434F33AB5067C52D6B4B30D86B87879EB30F2A
4D2DF60DB0F37E93617FE86B99155091B00CD1C752661E6FD38A10829B960897
9B1621A09866F698608A69CAF1C237843CC3FDF1067B38D8E44A7850C0AAD3B1
68FF9F66FFF07E01EEC3D17EF5CF62C3D95959ABCDF9800A7E580123D8A3E9CF
6CBBEF5E02F2C73CEF716DD3EEE3CF5539CBA88343EE7FA2B9FD6D3A26F3A9C1
989203CBFE93A2A932A1CDB5D328A77A569F8530BD8A670D670E1EAA22F40557
8CE55A842DC544E9B48122D581A758072ECDB196E692F0277A81DD3448CACF25
4C2AC54E1C417374CDCC26D299431800B89D54E41AFFA9B15366F2487C46E188
BEF09DD95D492E66AC5B229CA24B2FC518D31B7A89A935478107E1930E9A9A84
1AFF06
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Regular
%!PS-AdobeFont-1.0: Utopia-Regular 001.001
%%CreationDate: Wed Oct 2 19:10:38 1991
%%VMusage: 32987 39879
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Regular) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Regular def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-158 -250 1158 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECA9E5F91E1E0B5992698A7F3
F8BEB86C9BD1B318CB141ACCA92730554DB8F57A8A21370C885A2F6612188DF1
0200D203FB6B33556F21DADE387C352EB80799C9BFA76FC4192381FF39AD0FDD
883D39690055E6A12477D408452D16B726E759BFE286CF62450D5683C4EB0845
EE3B21D7D64E100CCE7A2B86926828DDDDCFAFBF3861F98324538A0799F67E49
72B96013BF16E190839B9D1DF92A8B6A610468110B7CBF1C24CD2CB1E994CCC2
4BA3DF5753B81CBCB3B71C63FFB17B3B47E949C570D03A4B162E12ACB36EA11A
22733406532DB9FF39B2B2DE58B270277E7B1C3E1A460CF4B6FF063F5CF37F5E
AC709027E0FCEC1B27227D8A49D0664C6FB0178976D6EB5B09B4F47B5E94D782
25FC9D56FD8EFD97D514EB2ECC5630ADD87D6ABA98B19DC1AB262AB9A8C979C0
59A76953EC55333F7800EE9330B7FCCD8C3BC325658816EA542654337DA7D3C0
407058CC4601BA7B6C6B2DA0E376F7D94DED19271029E32844351B475FA30E37
2D98E7D5E6340A878CEA0811FFF598E5E1617F2D13066E7640416BBA886DDF0A
E9B8A56119CE61E57FA8A6309245DF8BC6CCA7CEA55FDE2D7B6CD06E8C118928
1EE6CB47A4B7D7E38CEBED3A0D1F2639BFF76FAFACC17476D13F4CB31FBEBF15
89252E409F16ED56EC1DEAB4F330B7659E93AD217785061D581BC8FAA0851486
654C51CA8472E0FF71158D1D3285ED72ED927B7F750F99BEE45F5C77300D0411
A3D81B0A9C8F5865B057F75E8D97E77958D3502994B90340EF5362A99D9750D7
14286B362186F0715DA5C6039DE18044B8E67EB1152D6C0DC98D0E36E6D3C331
C817257F4D3CAF8AE438EB03B04E8597046197D67105121CD8F5DCBBABCA9FC6
55EC17EBF96D17329B7C8BE8F7D3062E20E83FA6AF45A0C932B5E6EFB4DBB928
E4511768F708A03FA8BEA26BEBE94936A426DB77A8E800BF093CF53914B71382
019AC58ACA79B9DF64946EA241C84569F2A13CE8AEC7775D014891054D978CDA
2123ABEA1F56B7AE95ACBFB66602930C7FF181D407919EE24F9822ACEB90CDE2
8600399C4B6A20B9F9372AE5FF89509FC2DD0A41FF090A6554331231DF4C7487
1AE978282A9D1CD19D8BC9A2C60B4013973946C9961828EABE87D4EFA0BD65C6
86674692C0F27E9FAF66DC1195124A60A6E5F01BF2C6D78355FB7575C229866F
C1AB1434BE0F4861EC8F64AE46D40D52EAC802878FF064922470D50F2A18FE57
DE5237FB22C8424FF3CC5990A998A735C12B31FC7F5E6CE9C732AAA4AE3F2C72
C23DD8504C426F0258ADB1585D75CFE278C1CD4E699553715048D27CC0A4E0DE
FDBA01DDEF496F6DE0DD44001E2F1363A9B1A38719B53E70C814D0FC7F5D069E
C95994EA648AB4D100B6B2DA0E1594AB8CC867B772253A7C92050AEDE8F8E58E
2AF48F64A090AE8D456458835F196A930F7E51B1E22FCA52B12375B2DA1EB4C8
19A28226AFD8F3E04598F519B32EEA410CA5C653EB9FDAA0CA007F8DD54B61F0
F8DF83A7B4BD041661945091BDCE083424A47790C81D990013ACC1763260E9AC
E361D63457087101F7BF2358A06084859C632C8DE35FADC38FFCD02EC1160CAE
5A6D87E2112C48DF124951653D19B04EEA5CFD0D994059D2B412EA2767BB5867
F44610C81FFE049D199AF9F5B2786D5EB2431E778C6E8A492379CD73BD7A2E0C
CB6634DE71F20FCD1939F2A4EDBDD0F026052802E70BF99E708A364F26D8F54C
E9E6737B552BDCEC37E777689D316D3D3631B00E249F9C6C69B6CAFD6A86AA4C
6A99C8E31C1937EDD12E121757F08B0FA776C9B5CA81DCBE00BCE4ADE3D82563
1889B5330E8D93749E219732A9097D0EDA15F697FDF47E986D08D75394C191D0
1BAE444F57905BDC13FC37C71444E570E4FB29BDA2AC99B7F119E470A70DF3D8
A0BEF04D5F65B5A65D41723005E36112CA620BD35BD2EB58AE5E9E3857813364
7AC6112CF380D14436EB36CCA89F93019ADC3D52BF3636ED201011C48CE48EBB
5396DE7E00FBEFA92D1C08B042BC662C1A1F7C66E163E70EA48ABD18357E76C1
45DE69B3911C09C683ACFCEEF6073FB60313DFDB06EE2DC0926033DD4C69B3CC
1D64D56E8C4D67722C2686CF3DAC966A1963D71E5BCE04F8301230AD9155117E
8CFD0877E8D6E746345BF22F1D18253F581B5EB462340BBA865A9BCD9F92FC7D
642AB9B36A969FD8A3488975D1441622A50F8DAAA71C2407D8E107D20EC952AB
8D3B1738AD42918C8C67320D8CA7A4065D5DC4D382F66D0949BAFFEDB36DCE97
5868D0B7F04517A74A3537C5F44E078AAAA1D051AF8A1E8F67BA55380E8C7833
1DB90AD895A3522E789A642EBB0E2C389CD709D6E4D7E801AC7B060D215B1AEB
6A1E1422A76D86C40B618FA651F9B438C9FBE51AFE29D5C492DF199797840AD7
6C95DC09BBC8829FA6C9DD70F59D5B837859558C7980A66D841AA118CBFD44AE
DF8072B2D64975DC69C90F571FAC194988A562D5934D22DB2E2D4F71E1E989CA
C7E93A298F7AB1420735BA238574F970220DD6856970A2F3C802FFEDA5C96057
B34082FD052F5BD450F58236E18F9524D68B22DD778A7FA109A9AFF70DAAF6DC
A9763CCCE0C2ABC7FECB98A9F2231135B123F9DFC44108FEB67AB095DE5FC15F
B3C558167F516B50B7DD79342422DB0E16F40B49478D20781E3A29C29A551016
65C5C916F7F335E0F7D9A39B0C0C3BECEE3AEFB793B2A86FF2CC4B61EC97CB44
6F448EA974CBFEE9BE0255236E5BF4D5E74E68DFCB278DEB2FD1CA8CD756A752
098B482B2F5CC538FED351B87E6FCE3AF4EB9FF14DBD1D9DD8E1021F51C96385
B1D5EA283F585EA749B76A5DBC2415FD00C067BE5D23225272B2C64B16F1D89A
23ACF1FB226559B4993C21A06265BBCCC1B11E31AAC2707161B04441AB01CF9A
3242AB6140017E1C18B52506FD5CE1728C1F4AE5CF13BAF3B59AF24F613A0911
7C1DB5FCB991CF211F1629248556F19F9B5C80D85350C28EECAC6E09D3B22EBE
875C0E8D3FD1A0A2A6ECA0654398F592EC7F8013C5AFCF78E8BC20ADF95CD51A
CE9C30DA3D7B06709C44F011D277F350E7168A7915CB45438F2DF64A939000AB
02807D935471DE4D40555EC96E763E29D0720F3470BD82A9DC29FB462AE5E27D
87183946BF0855A672391F1007EB1174B83A5A5CC369FCEDBF29C1E6DC44E64F
060CCD95816387879D655B321D70FBC7D5E469841C3D94C718F5905E864DE7AA
35C3F6DA438DB653E4B6EF027D94228D330E1D90E50503912D5E416D7741D55C
187C5A0608D6CEF5F5EE0517A348A90963EF1E00E0CE33E6550808AE2CFDC477
789154D48B8E32E6BF976114019232DE369155BFB33AF678BAAC6026199771AB
A67E9FA375989C9456BDDB6EBC2DB9408CFA11337D63F8BDED425BAD76A45746
B725A1806DF40C5FE2BCC93E5C27DCE034A2604E225BF8CE77EACDC0C9490913
2B0A500A4758FB34F182AAB1DCFDBD6686D396EC0F293BE1A8AEC53848AFA560
E3D63F25F29C94F753A9851B5DB350BA70DAE153BD7A6387822F2CDB796AEB7B
395E9DE82C0BC3FC8DADEB1FBF19F93F61B94CC6AD7395CE6765F7BB748FA734
6C5792CA8504A3AC3412BF8CA607EB12F3478D23C4277C812748B845E0C5A917
3442CBA43109FA27671E352897D442E859E11FACD699F5920443967CB85A2C1A
FA1074DD2629C0EBC19DFD7B390A099993B5687F1E4350A38923A580A6D19864
726133522021C59A944C34BA1C6DFFECC4A9EA5C2FCCAB754A76F8AEC3B1F0A8
B3271C03844BA0C2D2114747EB3CF42391948E7E0DD8E279A4A6E657302535B0
A25B3313E04DE5FC1AA80CBF2A68FF6C94AE48E75D61A97DE52E9F3BA8FDAEF4
853A2517440CB9C15859CDC7CBF8E12D25F8AC4855524C0DF698187373A98200
06253A129A2F8BA7A2B491D9814661131A2A3A84C3B053F4A7A5244A481D73F1
ED1A7F88206A12D63EE1C91E311CFF1C365346DF04B78EFDECCF1B3DD5FAF2E4
4E432098F06D3A65CF4B5BE7908A4D20D89B5060B20C8E3F797DF7EE2CD817ED
7D5697A805B1AD7CFD5784B25F3AD7999CA4B9A601C5D0FE85DF5D95CFA2E2DD
3E913880077E2EE5DB334F0F870F40ADD294197590E82875230FFC3154606711
F87E3312D48584EA15AA6255C1E881E6AD784357C7C32658CFA615819BBA1148
274D9D782844D0F9167F6E88A666F06EB894642096B3D2816634A59A9EE448DB
B13D7618F4CF2871EB3B5170A1B33D2052DE916506831582549AFCFB9D2BBA7C
E518242AAC5A445B9D2CAF2F3CEE9D5D33EA509C22F4EE561E68859A4EFECAA3
112B4B37964CA6CBE462DE5B5505033F77A19FE5E163B61A185B4E87D867B11C
993310C5E7A227BDF8816B6B60EF30F117BA3F0DDAF07A4B6670642B0816CA29
DB91768E907622FC109F54A8FC473B4BAF43DA1C74EFA83B2C90F3CDC9101E76
168C1F2E552DAE810B357CEC259ABB9D55E5378AC25B69F7126C639793233D5C
C1A4833F2185DDE6069646986907F06176556B253F7C9C8C26B6889AF3057141
1ACA7D8C235D3E36AB8F68D730FB955E04347E0673AD1F1898F255CD46FFD3BB
821C56B4F44B70749C520DA2FDD2853F2C5F8E915D471EAE9D83E656372AF4CE
5A6E5A34B8F7A3BA286A1A7FAC8FB6861E9B8ED51EAD26D9A6BDAD592071BEC5
75BB74C88102F2E55D298462661FDA02CD4FD0112527C92DF86EEE927CE5E600
7EA07798A4B9A6017D60FC01124B992441257B0333807E4C5A851A85A877B615
51AC2521E4F9E3D89D6DB12004FEFD1139693CBA2E0E4A4EB93CA85E89440302
6674669C02D84BD937DB4BE342CD2B51E1234E92FC5E6B2D41BA552FE72FBCF8
374EB170145F783D9DB2C06C831B8969237CB42E5C894CAA7F027E95F0C48494
03A4C29772C52679ED7C3B66C96EC223C08E0737FD80E28B650B62F1811CA9D8
EBF1B92EC67EC42BBC3D5A5C3D5349CF77CB0FABFC5F26E0ABF02DB2DB080FC8
DF10BA4A54E9C4AE3CC9C467C2627F59995781699101886FB4F11D9721931DBD
6A770F8CDF80DA0D6D535132B029E8C77151BFF879AEB05975E934DC2FDD22CD
6B39B802419FC877222043D32507431FAB9A549A1C267620938B9742071393B6
F1DA74ADEE20E42B145626CDE02BB9ABB47FD962864D9FDF9E7E7D7CC0AEF52C
6839FEC3D358A9A40470618178531EEACD37721F56D0A179C0582A7F28CEFD2E
5ECBC449427BAC81B31A80A0486D974A71C92691838B083DECDD656B5C082E03
88C695E910BDCE90F17503787BA056B07D81DF2D0CAAB1CC02537317404A86CB
B5489ABA24C9E0FF6D1D0F91929A1D45FBA36099E8D3F1D9E05C7DDA076F4DD9
FE73B7D1E30D368FA53FA2AF559752D9686B08930637076A214FF173510EA5E2
55CEB422FDF15DE326C7CEC560B2C88FFE3FCA6807A83A5EF8B6CC482ADAF1CF
CED2D558290977419945A9FEFB8E2F2860942F1EF45FE6CD98BE1031C200F69D
E72A8D383A09280F04E833D591665A8C0F50E6BF9F6FBBA1DA686CF52EAA0963
08F7782F4AC252A9CBD458A0156706987C7D3F30AD895A175591A7D957CAFEAA
66D0FDC747F0F8AEF0991A4EB126B8DEF9DD97A5EDB1CC11FD915E09A9AB1C73
34C651E0117878F2671C1735EFDC419077818D61BAF6222AF7E691099E8717F8
E5412628E7F6DA27EC8A046F03E9354705C62AFDB7D1CEBCF30EE37C8B985D78
3FD5187773E976735DE0D24F00C19DFC7ECB78A2F6903AEF2782106876875315
91F1A56E7D2CB611D9294AA704D65F044DA8D3E5C0826541C257515E552E41C9
968226042F1444C30DF6B5FB6D5C4166434207F479B97330462687D1F838EEF4
F07B14F02996F048A31C49039AF19017A396660915711E6C27323E3145578608
3B30710FAA262A55BF293797A1BD2D4E912B80B490CEB3FC8FBF8648AB68481B
CB9DA84A5099AA896C85093BB49C8BC536C767F184CB10DF1276DA0DD6A2504A
FD4A243FF3428FC5B541D8F2FA7411F371B3895AA6D2037A69F42F18F3A994AA
4CEAD8F7A080F28CAEAD36C206AD443FAD6F0C687C93B44252C8CEECA2F695DD
2BE82D779D6308F82C9C16873EDE4DAA4227675EA3E4A223A4BB37560F5A1ADA
B1D412AAD0B6C87C6CF98DC9903276BA0D836F4126BFBBD490E8F49BF2E1C0F1
A3DC52485643A7F091A006D49128372FAA789B7BF1F9C5C0754336186EEA1CA1
B99162DCDE4EA95315CC8303BE2A0AE37753FE13B5B74267531EBDDCB6517F95
A53659AA568A2085E55150116FF749B1FF9E3F6ED5209665659B0A98762196BB
DC5E00B1AC8558996CAC3A8DE48A34FFA56E5DAE5B390B24DFBE8D91ECF658E4
B8978DD37C80634400F759233FBB1B6D1448AA89062AF2E45B1BA4732E96D668
409CD6AAB9AAF8D3AA12B7E292BCE5BDF0FBE0A3C74A94526854C6F8ADEB552B
7E7E2274CAFDFCFA1F8B96260ED0823F94B9AF93AB2AA8C916422AF064230C2E
A90EE8D85B5068816C561272372AC98EAF239D1BE7A4C34810EA0AF3D34A3498
F22990464B7E4953198D902DA1EE6B1E771C74DD3701731565C3CEA89BFDD613
0ABA843179D99132FDD9A2F7DC187A480D2306DC435F11F337847861AF5AEAD5
5EB4042D30D14B781652355A3D2A0542EA25681E016BBA0EDF9A18226CE8A25B
105F5A0F2CA01B6FB70EF94E603D88211E9498CADFB6040E07CD127CA1A62575
934D385554B2B3A0C6109240530C5982FD14E4E924C749D1B7D4905C0C9DD425
CC86FFC35B8399330207D2C8B19311384857673E66E24FB68003BA14073E15C5
E1B3C64C0EA5862F4E2C339BBB5F43BFB1535CFF9D1820E68CC909429BFCA909
32CD0A2157892D658FD241FE79888928A2DA14E2D7051C41FD46552E7C939346
84DBF1631C7979FEBEC41765C6E8D8541274FFEC15B2AD9D2CE89B3130F2CE5D
69691729EA004A0FA4E165327B65015AB8B19798D7FB112F0A4D9FC584AC196F
341FA7E1D5E392325F12D8F83F6F3A654555F5FCF839B2EFB6C471E8F53224B2
2A04A78EF3F2EECC580967BCFB67F7EE53F0E345D0BF7FF0F73B02B1A5707353
F50B102BD5E019FBCA21D42B25F5A9CABA27E833A471E86C851915925DBB3F68
95C5DA9EC4F34A90311E65E583EFC43D4EA7D286D0DA84B4059DA9D992DBC643
9DA58E6AF4B35F3A52A41DBE68A7815DD49583EB7FE306903E9DDF2C75BC3027
B3CAF2C6DDDDC6FF153BAB13169E97BC2C94AB70E1FF207560C893004F0FF6F8
6DF7D7A4A0FFF4DEF2831F909892A0E0DE89BEE5E5AC425ECFC9CB8F95BFBCC8
0F4EFBD10E9E9A6D795B73BD975162F820E090422F74FD54B12207BDDCAAB6A0
0AB9D13BEC72B32DB1BB2F51039DC126314700F24408890DE86E93B15E8B5D6C
9FC225FB04124570D14638662858BCCF98F350598765BF8F4754E7E3E85BF3FC
466006968BBBBA9B8CA038F121D5ADFC6174D605760C61BD79BDC697B414EFD4
877E0A666EE9AE06F6CBAF4296DD7A4248BB8425A5F9C8C21FCB1072F74271FE
B6AECD7D75E5CB29FB0A23CB74464DFF46AB7A09D1FF2131781F3906C0803FDC
650432EF00530234F3ABCD2EE6577548E63D6E83F7490D50CB35C74BD692AC24
F5CCE620B10EE93517666AF00388F75E62DD956F083B1B8960C170298E1BFF01
74012508F26EE5FED3B0D7F8ED882F227F5EFEADE75C9E7751731A483994DE74
AF6A96DDB13A3D8F349AD934295DDA3381863303CD3CE2799F40F541FF2DC295
AE9F340D5D93D43A6266CB1AC364410F36D3C2E0C92CFF820CBFE2FCDB9FA16E
FBF3334854C5D749647822BF0869DDDCF62C0C4885C1434A856C060E47A84B48
7004DD8E5D0BAB11E05E5A0FFF220994304DC8F021F638EAE46D120E17AA2F3B
E2BD640FE21E6B4392AAF11143DA2F7126289F22233FB7E42E841B120EDE4E53
0064854757C590B0E1EA7FC5FD7FCA057EF0C119B80A5EC4B86920E3BD019605
94653E8B6F637D7C9C418DA0920FE41F22AB5FE53819C98C395DD7F11F2977EA
82CBF88C2F1FDD8E68C89539B2AF2E6194F26EE28509D9F61B2EE84BA5059F91
D8744ED7D078D733D69592324A45E9F80D6EBE8840178440B8F1FF0441EF2F23
E14DFA6EBCBAEFDC7595EB6986213CFC8CA53AFC3C55E00698885BEC4D957B66
B969354B52183462F00ABE5AECC2E1403CB175F6D1464A7A801726CB5F05EC5C
29B84F4E0F9925FECBE39D9FF712FA57FABE1CB501C2A72F10367B0D3EF52CCC
CE5A99DF42F4087D9BC551143BEE728F26CDD51BD6740F4BECB4BA53285958A4
FC2A9F5072D3807504B790266D5628C9ADC3ED0F815F721ED4E87813BA90B8FC
1ABE9BD8D76E3A8CDB2A5F1A74EB18D980463D81A0A4D35F75898BDC6F221358
40DFF0F32503758033797DDD40D3F9BF73B5FC0E983DC647C89AE1B02DBE442F
53EC15372EF7B9D9A9E2FCF4011513842B59D1262234B26FE6DB7F1FC801FE4B
6CDCB5E721A20F1FF8A755D303CA02133345C979EFF53614CFC3143144439187
8CFF3BC03839F4570A21473D0756C31E741A28ACEC6A570C974DEDC6612AB65C
1CD41798C76791717A0C11E08D08C25C05E1E6405508D6FB79796DA414759AE3
AAC764B86811F10AA6DB4DD56EC48A8E5F749D5F3A1236CE388078E809A163E3
459EFA7CDAF0D9B4424413B1BAA312F700249FDDD52F95C5C905AC6AF3ABF3D6
FDA1FE442AF603D8B5C489B6BBAB8415F97713AE91715B218C1EBA6EDBCA3654
6976B5408A966441909584E76D8C4F7B9F7D02CBF73271E7290AEC00657040A2
65609070DDD0BC6599CF95F7832607BDD73E86A002F68743D8A8D18D4B298A6A
52EB47BEC57730AEC1AC4F4E8C3BE479EF03D074AB54060126F00946F9EEE454
4D8D900CB6FDF3BF9A8F16B29557B04873626D90DC8D604320FD73B51A92E542
5F79E4F42388A9EAF2BE5F4B7F4778355F30528A2FB77092A78CBE9D094E9CFB
FBCCFCC91DD5B1C2AFCFA11B61FF4BAFBD1C377852A5F3D1D04AC9C488F12EB5
C4BF205672D80F07D571C499F147D25B03A44356B5FA584C105DE589548CD8AB
953DC3C7CBD1E1048E7BC9C340A73D175E88ADD1EDD9347032947BE8BFBB8C20
8C8A4A6985E84B41CC5A6A44A1F6142E0217414D6447F9187EAF94DDBC9ED83C
26F88BAFB54C5291EACAAE8D446DA66490498F5AEC52E90D533D6626BE1D568C
8F2DC6F0125581B16DFEC7A0042A777AD11B3564D5E542AE4A86D02C6B98F00C
22177324907ECCCCC27B57071B915F4E499867AF2CEE34900C45C7DEFA2C6053
701C13732FCC77977345A859C20FB71C62899A439A46C523D7A7439A5AD3F8BC
9497290F55155F8DA1E2164D8122D9052B81ED04392890F8972350993B40939D
2ED8069FB617DD3CEFA5EE69997E96F9ED7A2E7FE722341BD44E61FC26C6E514
BCE41E6A2B41331C6455AB5A8226659555A72FDA4D4B472ABAD8E7ADBF2FF846
69DD20A087F8506424F6D7860C9688C06B54B171051D512A90E56C294327D321
F6F925E57BE7B5D2671EF1A4495B0056A1D3A1241FC6D17CEB8550757C765E40
3C0898860818E228EA708CC6621D927B1034C9C62C48E1367FA203AEBE45E2E4
A9337301EC6A886C8BCC5DB674DA30351D2E5A33AECFBC209CAFCB4BDE33E69F
DA434B00A3101710078E0C04B5F402202DC0339655198522C4B8B15BE5BEAA8F
433C05AA342AAC01B71BA697BEA0A9483EE8EB9E5CB32CCE58811FEC229645B4
FF4040AB30BF3806BC4E06F05F66220DDBA5BA2F3D3D660CC0F9B5F04220BE57
FFDFB68A41ED145CFDFFD6FB378950392B6C6675AF34DDD3F2C348B285B579FA
962A1365443CB78DA261CEFED5D5F8F9870512E026F887BD3CD427B6AA8CA025
DF0AB5250B8DC67653AC0948623C85251441AC1083471EC74AA15BF8FFBF2A3A
5C3071D204F98F1739050C51C325BCF8B1F5AA9237A6F2C9E373342EC6B73AB5
2029862CA5A95C64C7D7B076626938EE3CD7ED4CC0CD15F94A2CC7AEED943A53
83613645F56AA206F56662BEA442FBFA0CDAF83D8C58418A93E4E63F3F4869DA
9D4543B9FA47CA8C6B201E537BA2C695BCFE7F0F53FC8ED20D47E1B35A842A2F
3B3C9F948692F237E228778C6A08FB2636938EE47B6CDE80E9D8C63FF9F3B906
48E169F7BA3961E8CAAE702FDC9D3E38AA92D921B3C4BC8F3A89BC190DB7B51B
3E15BD2B0E237AA792C38336ACE9515013E4AE8F038906E37CC2037EF457EB2E
DA5C4A78690959625A59EDC109E63E154A5957CCE9B4A0870D769C05D6F238CE
8CFBA9C9A44B32977C92EB86B8C0780CF798C74002F2F8BF6AB784505B3DCC3C
0E1CB12678C51D33A1836544698266F3597B4448EE133C91BE9F2784CE64D08A
E47EBCDA20279241A8C2E270879C78ABB782F330A0005DF78ABDD9FC368E0487
655DAE586916CED77D05A41AC6C210D3C673C98C056964839F79629A75965868
6555FD056C8C8BA0068369FD738712D5DD52CE892C8B139B17C509ECF07C2356
A9482BCA30006B23E90E9529CCB01117E87EE23DDB4A40DE8FE8F609920D8A15
28FCB25CA6DC2007A2722C93AB0EB50D13150B1D001B532146403EE50204092E
92D1D067B6D84064301C7F34C04A6B2BBC13CF15A0CBD3F0A6D55436EA9EB9C2
90E2B4CA64606F06141EB8E428CCFDA19ECB7FC0CB31E047087C6C7C32DDE227
EA20025893E4C7A1809E4738F3D5DF1569A33A8822A1C995379864782AD53084
DD4785A48A0B25B82F3E30E3D9DF36BD4DBF2934F620EE513F69753264392726
9E7168EFED228AA03678C1FE53D84E164F98713FDD58F27071C3A80E439303BA
E674B3A36AB53C6CFACD32BEC70BBD78B33459A18AE99AF7C947421469C13678
ACA26481A48A9E0C58684465DA86E3584B34E849027B623845B045DD74B42277
E8F30C3D6D1C3FAFF112EC2718E3DDBA72F5FDA55E36BCFC73586DACB628F3C6
FE8A161E202B50E6E7E31A0F952F2F1624142FDB0B38EAA8E51AF3349AC74E0B
5E3B1E5B80B06EF63A0629BEAA14D79BADFCC0F9AB4FF7DA80F31A8EBD8AB268
92781382F59109192378E4B82377EBC86A539BCFF9DCA956F1D0FBFE0C0E4C3B
F026C39C6B3BD5B55BC85BCDB981AE627E446E3BBE4E16D4177B3A067A4ECFAE
7450A0EF3B9E26314B02140158EF0915F7CE9AB504B403BA06A24BC09B78C4E0
30DBAA42C5A96DEA19BDB989FAFAA5EA321B5812AB097C440F0F62D2AF696BF4
1867560B6CFDA4FDD3A8C3D2E3762DCE0103324D81E20F2A0FBE6DF8472AFAE1
1D989C8DD5B53500D824BCA647074DBCCA06BC8F093FC6ED9C116ABC2B3A537D
BC36DA6EF5A42E25D26C6CB1E11A12C7A22E0146460A3BF2292763BAA3ADC3BA
7F2B80802690286CBB549198EEB467704CBA2A392471445EEB6F0348F3DE8F3B
027F6AE164AD39F6564BF603ED01AE30C12C8D9F2F62F3EAA0B769065C9D8C0C
3B56FC7A0D00935B0E15BE2901A6820CD2D6F9933E648EC3606E24C5F1EBE840
277CD7766AC810E49CD8DE27640BDE86FE95665BC6B723AE4E5B3486375883C3
0B85478E950A51C76C27689ED559EBE58C550F3962934F367AE04D6076E76613
29FC2710FF5003761FF2070A0FA2CEA86B3861F1FA77671CE3B0C19472DB7414
21BF798B849E98BC3CBD597E5210AFC977265B81BE7DE6E5CA7EFCCB70E6FC54
FA1606ACDFD7E843DD90CA6C8D2E32F310A24C265B49FF4375CF967B47FB25F4
4B1D95C8E23589B8FAF59A335B39C5F166C29B5BDC6E363E37D9681FE3DAD645
BD76E9FB603DC89D7892553A43C5668C0DB79960BE50EC62E0939CA4A0885067
F5BCA90F1C4EC2C741DDDDD4710B17E52C41FD66E94F009741FBADC476371F37
09BD29D37117E08D86D95693BABA3022C3B1D1051BF8537CFCE40C93827381B9
60420F395D3BF026C39CEC1E1B346312773848DC05D38D10038B596F84EF3141
324A5780575ED3B1FB15DC7A1C58CDFD1F81A79AF755CDFFD6742BCC6C91CA9D
56641C5C68B8B40EA166E3E2824701D84C0ABF2515A2F190859F3DE0E5F528BB
3A733644BFC2E3CE45CB3844AA1AF3A022D5625304BB188DB2D323700B083E6F
8BC76EF77C6E77994A21936F6C3CB4A6311588B4319FA22E72C0C523F1E389F3
9811A32FCEB1291C549BFB4705319E03CF67CE1454DE3078C170234FBAFB6E45
EBAC15697A51E4137B8400FB69432290F15AC467FCB959F34A67560A60D8D500
D778D15927FC1A73E3387543D3E86021F595F9DDF4721CF03E7A83673271C62C
7E7AB5BBECFC416EF39C5F1D02F17DF302B8DD0128AA439351966C88761BF222
9D9866B5A96EFAF6461A6A3D451B160EA1277E25966075AB8D36BC6DD37BD061
11E06C4F413A56E7F69CA7DC689D88A944B743571FA9FA8C51B74FB2CC5298E3
3844FFC07BFFD3066C9E612EEA3741BBAFF0150F2810A2659CF5DBE572B58448
760F1969CEA66B248EF12930E37CED4649DCD1D7C1BB9EFDAB98392D5BB3A270
FB3160CDBE68ED569B2CA7370ACC8983F543E9DE93971194E17B0131C960B84F
92DDDDF27B0F07AB17C38093904335526797A8C94E92D24CEA54F2A9163C60E9
9AB2D08B26C39AEE523FFE8F7516F24CF06F322E7F928A64145FD2117646C81F
BF3D4D3ED20C4DDBAF2BF0DF9A36F69F6DF5D084F830A4EE0BCC8E5D18470C23
33D857A1422A58E668EBF5283E13CC1C003B0561E7340419B936CCD17321656C
B6880626698AFBFA90823BB0018009BB06FF6D58D3D55009240342DAB2F47B5D
5A4D530DE7A2D6CCD96DCB64E0896F311BDBB87AAFEB8C9441561271D66899D1
4A201A79438549D75BBD6E6CFB72CA4AB1BEE9F3921ADEA87C0F323C2D41A389
6A341FCD3070359A740D26C8787CE4FFDAC2869BF69E0F3C38B5C637F8C82949
4BAC819A2F73B12155156D8499C7A71498638B3767728B251135C6618E9390FB
5583BA2AA3688B7C548E3F39AA962917A98856F7C55126CF13864152FD2AC5D8
41BDFB09EC0F393D1D07D3894F0F8743A03021D7E5D3DFA77C5EBFC1FA8652F8
D1E2C61AE815145141731A9165FFCA7473C360571693035C78F67A438E9129F4
DB1AE70C94832B1D034B96735E34112F79EF6599E45EB387B49E99AEB8DB0779
F861C27EF899C4D063C7004EC42EF2402C5082D484AF5EE685C5F8A29A304F93
C81A8EAC943C6CE54E4990C7F57C89305D2E3E549E3E6F6CFAF17E9B408BAD27
D6074B7EFF36E3EE67DFCA7E44BB7DD786471FDC1F85FFDB9CE444344D04471C
3624FEB31004F033D377A6EFE84287CAA8F335EA4FB5C4D2E96069FCAFEBEE9B
530F30682265DC37550C63318D2E8BD7B37218E2B4EC0A94C48B496AE56C5931
4C2D7FB5604173242CF041FBF55B87DC666FFF538B2446CB5B5152192EBFBF18
2F0D752C98C33C05062C2F631C4AC3FE86B31242F68359214A24B5CC5A69D930
7344F53BA440784E4F557B8584B50526EF13FB04B7D4B3292335A42356F65803
974FCE694324C8CC7B173D80C22D5C8E01A5AFC9D5EC4969A9EF331DA33A9EAD
4D8E9CA84F7B70846E33FC2CA559E3D625BE7F3BD246EDFA194BCB73B3B271FF
CE67732411BCD84ED42F448933910DA5841E1D145EDEE3AC4B85A45D4A8268F1
9C4140FACAF464E2380291D7096ADAC8665C0B8572DEB4A045652901BB21AAAB
BF2C448180270037C9B5E514E226D762B13240B7495F715F800C1E0E85CF476D
0CC3033BEA02D73FCA9E43E2D53CDE55A7DB2194E6D87C77C006B91C4C96B382
1CF003AB78A9B85308DA90B20B6B83225581B23F00576F0873F01A7ACD72330A
8EBCD96FC01F50CE9ADBC424E11F44885D335DCBD995EDD27286B0706D8CEC5A
C289BB9A3B54AD3D52CC7AF1183764BFAC4A9DDD80604E6613C61179884EDD40
B3A6EA496DE182F8F910F3B6F03C3FCC7D744D047286E84F33059F987D73AAC8
DE9859D81CE8766386D3D66B2901BDE280D19EA134359F41455E01DC3789F807
2D103220213A84635E8378D840BED0025D7BB90637DAB51D26D18EEE783970B2
527C6F5D14B09DAA9F0C473A48B65C339105908EBF40CD733479571DD3BA1F38
05DDA8D4A7C7F0DBFEC6E8893BCC7CEFD34C4EF059E8CFF9D027F7EF204763C7
C869FCD783350DDC662824B9394AFA0972E634F1B6B714634126105D55029C1D
33CC93E9B58A2B0CB14796B22D6A3A4208EE3B3C182B00406EE1A9DFE12A7A18
8AAD0788266B983B02A342365A5B30FB0073A339432B2B148B6CD6D076862907
17E1E5A321FA66E209B764EEB07F4F61FFAE933CFB37813EBC84227255EC85BC
4A43481E3B4DA6576EF8CDB72FEBECAD42D003009B5E948D5746C8188C70D58E
6E3BCDB45E3976A8E731B6E15B978E4E88221C5630A1707A65344EF89F1AAEFA
49B8877C90AC20622379DE9C5F5E69B0A42D5751C2CBA873ECBF081EB27E28A9
756DDACEA20862F51C10E31C9C268CB457B72DD89361E52FFE1E8D9C2F967738
4595AECB84A2AECAAACE74E2D3672CF5ADE41B2DE0C974E2955BB9465EE79A61
431716F9DC509D70F652B1B2A3C3AE6BF1B61448A2E0D12CBE26091455815D8F
7981F4B81A4FCF2D9E126230B7B98A6E6AA26895718838A205EED57D560DD14E
80CFA47A5B641FA68F0E2938DB49FDCA68A606A612E0C7E7C327AD0D42725A9F
B02143ACE6CA7CEDD89BACE15DE8ECF586AFFC52B63E40BCF720D3DA3D7F669E
60408747CBBF7C149964F7F7E2715E0A8CABCBAF08B5380ABE4CDD7411399452
53BE085828A0DAE6047322EB597276E4E1BF6071C66236E53362C298AF40E293
2F1142E643E91B8C870F3AB8287794332784F377A4EA18CE93A4670209C2C3AD
6CD21FA2E4FB940228F52DEEF30B110A05152406E86A960BD448C598E3BC063E
0EF740120F5ACF61A9FAA753C5FC5C0A20F53DD57E53AB4918EF12C7351EF004
2F54550A14F1EDCEED4158D28590EB20D38CA1C41BA8816FDC0E5B85321EF659
D0D19E4F54845E50FB355A9AD432B8CA038B95242DAF8916E996EC420DAAB656
AD4B69CBB381374C54C1D050C317CCD6E10A5389A64022AFB6003311B5AD4674
CA6A950C16228404E34F417CA54277267B10F93F1B863318F4B7FE84E2F36A5C
5BB98ED63AD2461DEFC7E525845D2AD73B1346A782035222E8BFB9B1073541A6
D39C2C58F662D39728F48452A99092319FB660296E81DFA358BB139EECE5F5BD
0DA047684AA8B5CDD1497FEC3FEED938E60892436D69C5766A6D044ABCC68DFF
2DAECAE90A4C62B56EE1892043296F0BFF1A5235D0B45199744B11935EE729FA
746D48FEFE18946E691B7BC6FB88447DA5504BE4A034857974FAAA6DEDE44F7C
521EC665062D2D645D0D81D0D2DF6AD8D066408D988D658977D92CD9946014BE
D2B2E26C3D10CD8511557B3A570CAD7A8C7214FFF0FDEE176235B9C2FE36FEAF
49174FCC3F28825F4DAB81B81D1AB8AC0A62CB72D1388558C4DF975284C7BCB6
BB4308ACD10976B1EDA2179F9BD5C94DB90502553342F70D2E0B538D51B5C542
B481052432BFCDA074FCD2D6AA5463951C492336800DC20FCB77E914BF0C1BE6
5CF8D8AEF11B158CB2FBF8A8F4235229A2C91B27B5BB2735E6B048BA59E0F1EA
9A69AE8E13367C8C43EF2606A514721CBDC7A20926CC5D7F8AC8456DD95B605D
71BACA02DE403BB1CF10BADE40BE15DEE59B295A7814E1AE8507F4E5C53E03D4
56935EB8D037116261A72AE1D8EB1DF1969CD2196660E394F7E8154294E72F76
B8C40F0F92887FA97D5BC4D72B91E0873455DE01659086348C197A50DF8DDE11
76BA221CD35DDCAB1E76EAB11A787D2351662362C2A69842401D7FC5F3FE5637
3EE5379AC5B6AB2AA3CD1983BF71288236155AAE2CC5D80D5E9F955C5B3BD54A
A459D6855AA28B1ABBAAC6F65A0EEDE6B5CDE537326E8B0741C13DD573F7D61D
704172860DB1780E17C57CBB6B0F770F820D7EBAB70C9DED5CB8CA0E76478F61
BD6B281366E12615E2B9727D9489FB5B70E0D07DEAAE379CB5B80A8B2B28FCAB
2D70606E23A7BBE11252649EA5A83CA301E46308CCBD2F3B8D2B07A24603417C
8C5B5831E507EEAE105D00153842742A44E1605140C636FE70C323DB841400CA
FC8F01DD0F506F67FE40DA90AB65F0001BB8D1AD857806F4E098B382312FCA29
1F7065A21329215E1D3524F2502847080ACC2217DA39FB2B71AE71FE9596D3FA
E1A5FDE9F7D32203A70351FC0E57352DE5B831F385134E20D92E36DDDF3BBEA1
10D5BC9BD8622D31A2856258262741C0A94E7CF4D222B602CD987FFAE3713E86
3CBBB0524D00D920E275F8EAD3D464F918A09B7A1607FD80DFA2F64AA721253B
8D9AF2AB34AF13D96CF2AD4A71D9032726A216BC01F017E8AA964722964C4544
3B809C65B97948EE1F19297E6173D3906112CE72CEB23660B5CB0DFA77AB9572
66EE342024107033F7621F0AF384549280077E92B07B42270B36018874698256
4594CD58E2645F627F1A6004F28C68B82D642680D37C7FAF9E1A15ED5DF0006E
3E1F4200A12F8648BE202C6AA7A4B5E3255F704E23A45B816A31ABED3212D478
173DBE42A3EF516C94C94471C50CCD69D5548DCEE991103653395476ECE59CE3
C6243B11918492B0367189AFBDB4147ED0E239D02C5D7AA97BDA41EA4AC7B18C
2268D3F9006C2FE772A3AB753117514E259BDDA8665FB0C1D7C9B3DB98C074FC
5753B51A7A48D589BBEC1E1865F4D02A2DFB3EBC5CAEAF8A7C99004614A4444B
F776BD1E1C2FDC96B820085177B9C667AA672E5BE86B9463FFFB50505058BE17
9A054CED047961E7B8DE3CF9CAC06B569AB690FF49CBDE0BD193B23FC6AD6D77
9BF7304230F685554C2E45FE506F9D7C9FF165C531291334D45151CD65A8C05F
5CB477DBDCC6CEC7CABAD7BFB7C770AE86EF2DE31DFD6F7B28FD2816079F3B1E
58757827E087EB497DA9F3010D51EDE44CBB08606AB147867F212500C17F8385
C2E89287A66D3418689656EBDB174602C49DB1C9F1A57322D4E2CA09ED29DF34
7C7E9EE51BF6BB5E774B12A7E77CE936B0E2FF26DC79FFAC84F17E9B2DC948A7
7F853760B0FCEF8C071EA7705468C7319248F0593E1D5F71722582E5D3ADB530
6EE01CACEEE54CE869845E99124399A0F4BC66F65C412A67E0F9D6A47ECD6DA8
26B464C01A9A493B6C358681727929F0637027C9440FF98CC966AE085E2F6602
F5858FE008A089F5DDA7E51F5AB0678226D15498DC53EF325D53E42710AAA3C5
5AEAD65CC02A07F53903BBCDE50B1D51BB9F0310C6C42718677893E20FBF808A
D317222E220946923BFD40EA1CE162AC4486949A0959D797E5ACCDD2387CE202
424AAD679E2F298C80591512513D4324F1A56B770543BC08DCAB8E5BC60403F1
20E81A13D82270FA00F754E512D468B98429EEAEDE5121BB5F73872B7F7BDA46
8E52B567B35ECDD3C4B4C89DB02CE2C4EDEC26A9E21CAE2780080AA7F5EA9749
DC788D995C1601A0DE4811691F27E4A6860863881BDBA018196EC1CD363CD07F
CA9C7B3F889C4800167F72053387B4ACFFA44C51488095F45C4A22B0B92D155D
745AF2415B1EB891104BEE184A2A48B859286523CA2E19743A33BDFE4DF265F5
2B72324F46217E079D506C302258D91EE2BE067ED0100E6273F84757A55A8A37
3361258757283C557C5937A7180F8C6EBDCA6B94DF1623BCE8B2A3669E2A3904
711D1FAF68E45F4CE4B83F393CC1E7B8476D2867D2962E002B3121C59A0B6E69
2C7E5D9E1FE20EB43AAEA1222818D234B14D0C5188283A9AB939005BF06279EC
29CBF464D9954FEA766A11C757B548BBC17671B3CA247CC8583F8C244CEFF89B
F4E6BEACF20543545CA8FC3E3D43CBA3A1C82052A7FAFD3517858D49DA7AECBC
832F11BB045A0F9DEC3792FBBCCC18C69F76464C96AD14BD9E7D0C3891523C56
7BA3624A09B55CCBC233A11F1842526DA5A309CBF9F0BF6BB6E70893086CF7FD
BA53FDCE48FAFF04F0B591E9A7555A5EAA6EBE150E184BA9E92D615A0D722172
49A28FACF5D3D740755225EAA19F6BA5012AE3395C6FAA80C9CE46266EC11242
C1E7AAAB918AC75A153359DDD8CF4B4D5B443A0435188F375690E3770D86FBA1
222AE4A64448F74CFCF8CA95362F4BF67C2BB4155BBFAC54A81339A5B95DD00A
2B1AF0B35CE248CC016CF0091D32B65B4CEB8CFC0D4E16C81C6AEC728D853FE3
869163D0B9FCC56466FFED2F6B3243F8DA7E43B549779EC4F0C43185DDD5DAF8
278EE91F9EDA889B093F11A83B13AE3B926F112B947A9207B6B4A04303D2FE0A
541637A17486302914A1914D7FDEDC555356FEF44FD1EEE5A225351001416298
E6B1C80375374C8238232A06B0F3A23C920CF90F647A3663294E42CBEB5244CB
7CA0CED8513EA79A6D7C0D2052712EF8A984D8A3376BDAFDCBD88645F5DF4C4C
C11D99883DC077C5EA6E47D8B4F90A263AF19A590C8B0674651BB6E776B1C39E
5CEF4B8690674F5970203F8740EE47E701F85874F467BB8999EC817609495C8E
4D2347AF53DF1B52EA655CAD8735D36AE869843E89AB8D5E4F7C323EFB4461F5
D3297E7DBC8A65E44B4048B84AD59D3CA5DF34F82D2791824725CB0B6AC737F5
701F50CF2302FF8CE45AAA4892F7791DCEF49717E11DE5302426B7E82A5AE09D
C2481116E0703047073E54DAEB54867A913C0600477C422B7789B05F2DE983AF
9AC845B14A7A3637B7A5130C620CFC139856477E9D13EF19B3AA290F50862061
F763A783AF2767E725753CC0484BA77044793DE28FA466B5FF7AEFF66E8DD8C8
E52C58B5B7ACFA4F1C8032E7749F6FFA25D98C4C3E8DB4F08C3FA831FE0877AE
4EFEB33FF07616490D84453160390E93A050C733D9BFDB85935A46FA15CD5F3B
7AE2E9F24FB5BBC5FC9043102595E26260828904B9C7E80A0A35493ABD017471
7FE886E451BAE0DFDA05B358A989F3CEC15C02CF163CE287DA6E1268E77FA03C
3B91C4D19BCE59C3B64CA8B5656B3B0877A578E9B343D28987ADFB3CD34987AC
9EA84CEB3E96B8425B6B43EEBF42CCDD26B815F83EABDB7349849EE5FF1B5431
9452038D9873BEB08DE9C2DBB0BDE7A6371A215361C7FC9BCA558FF445F6288F
BB77A0C5DAC98BFD6840076C08B88A63898BCC2212229F8294AC19BF85926E71
9D4A1866080C4173133E2C777AE6830CF794C89F7857634B8F78EC5FE88D41B0
82F1FCA83CB52DE4A3515CAACB369FD72FD98DE565C2F87953554D9301E05BE9
34A31226288D318326AA4F67E070927A51078B37C68AD49B1A868EBADD696C90
0CD46AFB572956247BD8876657472A6C6F2EBAC453913D62F0634AB4944D60E4
B637E8E226FF7414E2C087C97B0785285E76AB2C2707D9BA28EED6AD4389EBDD
0F1B07467385226BEC295BF4A1E5B226C584E1C5CDEC6BBFDDBA2A048CDF7F03
244B75E1C0C796EF1A76178F3E9845D37B72DA96FD0EFC5845857F160BAE9EDE
DC92B4B05AC302759A9BB792DC14AD74F49ACFDB6CFAFA7EBC0ABD1F48783283
3CECCA1E792D43E3C6BB3763C7C1D9299C30FDF7E285E37D66DBAC0477927DB5
27F7709F81DBB656242660F7872C74494ACDFF8462A2D58F041591166D9DB29A
FDADDC8807123DB2EADAB62024208C418E5B2A2E2A8991ED819F27BE49A72328
AA8CF779359347BE0927AC22F90F42F3FFAAF42481B93DEA68B15073D848AC4C
7EBA05A873D05C34DD1A43F1623332AE22B129C5613B167F637C167BE1583798
212900A54CC53C654EE10E860FDBE991E0BFD789706D785EF99DF8A5BF704BEF
90CEEB36F8174D80E081A7B6EE3AB549350A84B8EF80CDC13A64E5BB8961FF9E
2E502E1754CCC42E0F979664E60E0C845952EB223B80D80463F3BA8875F05F59
24E47EA7722A3E762BC1370B49D323EE186E4BE1DBA6E2F8DEE31E2664771A4E
9C36915E11F3037D2CB393C714086F36B9E80701207A57425D2F2F15FAEF3978
9CD4229704427503A37129BF9795EDBD6EF91BF98297AD316CF08DD8F58453FC
53D119A9C8D271E018A5B8BBC478D5B36C2034983399CBB3BA751B91F3408FEA
7E2EBB3F4BFA926B78A6C21053D70418671DB91D412354CAC14DDA5B9325FA06
FAD000C7F26EF35222E017E27BA4CBEBB7F3528081D6C2530DC7ACAEC058DCB8
2F6652125AE116CFB46DBD3760404BFE73285B90B7DF6BF7F740882BDE736972
904F44FE4CA64E1C81A4B186A1CEB9FA51FAD6192CF4BD5F41DD8C598BE35D70
52A6462B268A6D818504182A5B3630D2B1D040D15844757425F825CD9EBEDEB1
CFEDB4144606236CE0F6CCACDA381740AF5CBCBC1B1A89E6582FF741F2E7BC93
3EB4035D664ABAE2F49DBD32B9DA1B8FF6AE867FDA6F536D7DD34C523A68D7CC
A271162FFE24AF7071B3ECA9E22BEAD1A32AEE656D6843DE111AEB667CA9414F
0CE9B66683B8F0F7FB0F31844E7FB0A7B29249A26AA119340260BA7EF0E69349
A59C96CB81E5771793F1F58ED785F746873B369543F7406CEE232D897A2C111E
F17234CC3D170BA4B70839D1F03EC34EC5A333D09A3F550F497622FFF8F3EA55
F8FE9E40599FF9506CE018F26AEB856149814641F3C940FCC86A6210D1B42A82
F431E6CA6F7307978F51962CEF6432521DF0A13BE95DA52FE8971E4CEE5A8AF8
047E0232D4F5EB50A7764D2495CC4EC1F3235BF576AF5E72429CF720F5C8078F
786FEC0AFB2E27B9D650BF231235FF2E6FF2D154EC72EB0325147F65507124BB
22B22962F7B296502768E1F2B485D42987EE9702927CCC45341B4F754457B528
62182F035EF0D5288F45A8825EFBBF641C4F59B21B1454A782CBA10E6B6FA023
2D679D450B90A10D05BF7073933084B7C9FAA0C4B8709B0AB5E150D9077D38B6
E1D08536AEE58C5C55889E0EB7F5E9C6035043C4EB47FA0B240604FC8396F14E
05143DC6073631268CDF402815EFC804542BF18EC9E7DB2F0220B14DE1E501A3
0FDC9661A7CF01C5BBB8CF3155AED7C2E2F78B95E728013BEAA89EDA42DFBEBA
92C77B37DB53F768E55F4AB02E0B7C767604657926726D029687671170A69689
4D12BE13CEE604EE74B9EFA681A9AC2E0ED48D64595B125A1AB45DAD419B916C
7F00F2C69E80DC03CDB496757A9C979097D990DF06486663B7ED50FE52B8E9EE
C3D236A15F140D1714885CE539DE8A3A5E9850D9A2566946ACD631B5612AEA9F
D4DE902FCDB7922F56A6152932DE8C63A495084070B44EA98C9EE0429143410F
EBF3947693CE1B932E7C4978398F370045FD9B087D012F053EE17B840F8175DE
9680EE575D0F87000CAFD985921D3B7270CEFFAD3E38938CA4CB2A882374CDA4
6732753D314CE6412DA578EC195C278D8415436067EB334AC3A608FA49F6F69C
D3921DD793531B5E560E92E7EEA311A3FA1C34844815B081D26AA400AF1EE33C
256CC15E6DFCD68D27C6E11A6F0C225EB320DA27653F0AB0495C8EF9F874DFA5
86341E9435AC91E75465CCCB957909B15F4AC8A447DF73FBF5683F85DE6475B2
CAA635A666E6A9124EC0A26A043D2CFFB60ABD1A77E8CD5AB0005102A96EBB92
58D4C8478DC7BFF763FD5ED3C2ACF09ABCC56B089666885C8D4BBB42B4592CD9
CCB7D75A9742DB8DE58B924C895EA9D63C83DD1E8A4106C3E4C9648C4B18D244
42CF0E726974BE164A05EE21E773AD74B9568BA574FD6679956888B1A95A704E
90D8CA14B5E47A14DA1228C5FDF818857CD32DA2B368F927F6F235FF7EFDB2B8
97D5049885524AA8782D64D639976B75A1DF49707CE0763453118B217829BF10
B7D81FD0D8AAFAB1A9BBAF9F34C25406B0376631AA3695DF6806057AA493C6A2
4403D321F224523BADF6FE70EF6F5750354E22EE02A7DC0D67DB0D4DB3D2E1A5
431695F7D52659D6B0EAE8E1A1C2DC118E971B77880F4473944665816BA236A1
9A5E702E9165E6DA2FBA505424974097ADF2EC20B4724009D21C92C0467835E4
63D5157B307D4CCFEFECAD4C3070BA145296B1AEEC77669E821D28D9C8931070
41443215D2B9C4D2921C790CDD2DE0E0B36A2640851100D9FFA2D64CB61DCED7
92B7F104046B81EE48FD721123DB4491486B4BA7A1F7B4A669F4D0BA2E4F13DA
AD3A76F309D4510D8AD1935157C67EDF2DA5515FFA4CB09E31EED9AB43FD4C84
0865632A84F0A3914CFE9C1EE5B74D9CD1B31F08B47EC1668DE194DDA30697C1
E79AE4AC5FE4DCFC88445FE929687EB96DFAFD7DFF2831E15A4DB97E24C98D4A
18185C06D76535B20B8A660AA01C10CE0FA88928F2AD8A47B5E98281173D5C61
0A6280249557BC35733F20826738742ECBA83A1C9ADFDDD5504F3B1FD88725E0
ECB20333DC85226AA7678D191C4170F348655C078F579BF93789A73C3FEA941A
F34C92154037F3328E2500FBEAB900F44ED506D0D10C6BA6492623C46552AF5F
439355D44371DE7F670CDEC27A7746FB0EC302D6A61E3E7DD95264A47F2E5A9B
B3D0FD9BA81D2BF584AF3235D9F7640B59E588CF975CD3A5797C5792D7ED1C06
1285429D5EEDC020E878A869C8988AAC7D768729692B2E1072ADD3ED61DBF80F
13E5D4F0C2EFF9F53016C82FB5D1BCA8690E59827AFFDE6CBBD4C719AE334AF7
B1346D77C67AC8CF4C0199BD77E9C83F5F69B2139DB97E28FD1F27AA55FDD6CD
90F69965F1E5CC5268398A7DB05AED0AF931C12260A33DCD4A3DA480B8CD268A
96B6AA68BD164D37B302D16D46432F6F660C6CB45DE7A0701CCC770891FEA110
229E8B26B5ACE4613CF1F228B433C1F77F38E3D75C03054BB4859B9A995A1D61
D3C45EBE78E78BCEB401C32FE6A8CD58909FCB0CEF0AF56EDA7ACF2BFBB92B46
CF5F95B486B74F8FD9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Bold
%!PS-AdobeFont-1.0: Utopia-Bold 001.001
%%CreationDate: Wed Oct 2 18:24:56 1991
%%VMusage: 33079 39971
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Bold) readonly def
/FamilyName (Utopia) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Bold def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-155 -250 1249 916}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECD20651E6159D498F85DEA98
038CD78953484C2AB6579DE0F8455DBC490B5E1656B45A31736E5E2BF50B8F31
267E916812FA4661B391CCF31C1CEF974E371009854CCC04B88163FDD69DFF46
307B783974C408286274E78CEFDD99FB253F6040F96E4DFB000EF00A93CC110A
AFEDBCB7E9DAFDB19E29736CA84017FBA4C48D67F617A0937229695652772391
0B47379ADCE97C1A2272E8ECE87A1E0B35CFC9400B90A330FDDC52494432E48A
07A5427237AE7DCEBA59F06395833B628C8BF425A38348523AB24EE529E70F6D
E36B4FCA848B48F5D18F20D88818239EA04A1D52164110F10A861C7B7AA87786
3787FA2BB85BEF178696D7433F83886F07FE61A11DF621C607226F24F7EDBCE7
EF8B9A9C547562D02F4CD5A7C1C4E9CF749B6E8484911EB05DC8C54A020A5376
9746976D0F3E7C6D7D6D03D38DAE94B64AE7BCB30EA45A64C8A37114EA85F851
5E5F96B454764A111B571111C7198992EA306160E302F1BC74EBD30F86678687
F7FC00E9E3CDE46A18A27D24305A3C595197D22DF748F133F070C630ABB6DC81
263ECD7E72539CE014BDF4B6F329B383570C09CE92278ECC0B38FA0BF876EBEF
458119485A6A70B3C82D9CF63A2EA37E776AF51DD37736854F8CFF11413C0061
18E2A555443444908D6E49D23F564B971C26A335C7A93634622FDC1D98982CE1
CF21854B959F0E1C248D4355FD3C3479B6FD320669A68F8B4E14BE7C83F37CD3
2978597FA3D1316AFBBC16678C2C59B2FC0611E1783B4008E87AF14709204F1F
89B9D7B4CDA3AB6D73C59F9482ABAF988D76005D0FBA343D16CC6B70A09514B4
ECF3830287F70A114EE3EC397AF9D0BAF96FCDF07DF4068BC6D37DA18433DB11
57390C4220A12DCD244B0AF7DEB42146446CE11979196DF6FB2F2DD2009DE250
50C8789E30CA65A134C5633F27D18FA3864E791EA66B2C531F66D1F0F8A3D997
58B704F5CA15C2FF5D2AB98C66063FBE084A2DECAA2BB203E72274964394508E
EDB8288CA707E7FA1EE5D115DDF587BAB7D33126388C77C8B304AA332DA8A555
6CF02FE0D3CF24F559C515EF85C7461E08A9B3D7A076AA838923AB3FC3EEC3A7
27857F176FC19609A1BA23D34FDC16F7CAFAF6ED7DE6AAE26AF1BD5E5F885A92
D9EF6D9F73B1DFBC1D2687F67ABEE3A6F5357D29234A96C1040C62837132C0C0
109861075C0BF8D42B0CD660A9D67E9BD70AB9C6BAF7DACADC27DD787F9187B6
94E813C375408BD04453B4590919873752B5B5B42C4E19F7190DE0D1A395E7BA
2F0748CE7EA16B5EC546A8CD9E1D6F2A5F3DC8E9097D010D44AD4A1395D02B04
2852568E80758353BB0793695467D217777DB7421D3CF74AF56B3B0737ABEC1D
2B5226E7ED8A11F7C8B663A93768636C184CFD0527FE2C6707A7432B8F438A4C
EAAB891B838A556A06CC4B9458B742A742289E1EABC849FFF0E996ADD64F49F4
6B2C9D49C4411FB479E320B141657D3185396E7C5D3CADBFC44F627B81BB511B
7EE898294C95B27305BE8F51267282CE74D4E56982E5A02B06A2A33398575394
2419B9BFAACE885BE6FD88C758266CBEEBF5619157A268367AF6D49CB9DC5970
487FCE04C408201E52EE64D6D274860C3BF880EE09F99ADA9728F9AAEA385C18
11F240BB7390D7AC278FB9B8E12EE6324A25ED440B9DD6DF82B5C4F4521DCE96
F730499E509D89915D1A0D196A3C78A542FA060B06120B1F02A073AD46436378
570253CB436030382F9C0DC0880C52FCD5B1BAABA354F9006C574F5064917E30
4F6076328CCE20183026D48B5304F3BBD8695E9670ED556CABD3F432E2D3D99B
ED9E43439B6ED9F6A3EB25C39E91D8A28C719FA168FD62E9FE746407EC580B04
15E66668E819A82343EB98B9B23778D5A4A116F15F7B7480581E5C43A3BC3B66
4ED4616F4D55489F4EC79C638294786A5E434C7ADE89F233778FFF9BA3F99E9E
9848997CDCCE777B7969F1A179978479FE068644845F967D4A15FD6DA786D04D
89118914A9125AA09D290CA4C68EF82D01A6FF3211B5E67C0F9AC620FFF89CC9
D447023D6436E312F9064EC0DECE0DADCF082DED6FD3F0B0315B7D805FF90D54
BE4B10F5FFF1536530031F36ABE5DB03CE76F75BD74EEE82CC8E5B1302724472
6986E0376483D360F1DAF394AE7C266A845117CFFF22F9E6C2DD7AE98B680C75
179F46BDC464E82E8404B63AC8F31BB9D7266D19F605EE58176BDBCEFA0B9350
956E5AD8A5128AE2D8D5A85688257A0ACAEF3803862F5380F0EE8F6AE215F867
9BC13B7748AC10F051F1C9FBDC40F45575AB544D8C76FE23CD6DDC5BD5B800E5
CFB4F2055DC28C1B3943C1A7522EB751283C4E19D6322290CAC148DCC66FA03D
F92D4F5E3D339C6D4F905EDF894ED7BE58F53ED5C7BEC9476F64C500BF46DDFD
3A4ABFA43D98F1ECAB3421F17FFCF0BDBA0F1368E1F7714D94E9AF62960B850A
764ADDFBAF8CCA05967CC58A0CE61C188D70000D4AAA4B05B19BC6EA55DBD955
53AFEC7C43EA94A5EEDAC270263550BA05C6A3F1C26417A17FE21F38D12FDE53
A26F939555CDECAA0F42E48B1B67156EC16375A3F547006A4C67AD7E76C12FFE
6936ED20F9AFEAB666552ACE25962083110D4065AE49E97408700F9046A93CB5
62C51723376390B53891FFA7339794CC0B767C4F2927A55D3AFBEAE6834B9A77
851D5647A8003841A84F8CF727A3839EED7DA6D478AA5A754D1EA84045296262
17F6F6560C3DA9F2F0D065C88DBA642AE02DF232C2F7C24AC4DFBAC85A8C3C99
D0EBAC0F32924E1C6F28D9A7053882584E2601AC0D694D26967882E8F13AB29F
8266F1F013C216AAEDA4CD5AAD673C7735719255CEE894A7B673A1F49B6058DB
E48869E2D53DBDC4435C0BC117638E1120200E210139779DAAF3AAEB2C75EA05
7EF9505BB13D08E378C0EA28694A1F1B4177E562B6B6620FCBB0A5871E270F49
81DA72BF04723EAF2A8164F916E3BF46FCE745EE5D955A15622E4A05A397CB47
F87BB44B7A86B8E4654F66EB7A2F62431692C7807C74EFED19B582C1F02868F4
9BBB4832A51D80F71A7138C2B0D3BF8AF70F68189B9E2F1721AA25932CA9E1F2
A31CF7A1E465ED116512994EAEED2FCA0736EAF6D1A25D777B6E246DD5FCBB32
A326B58C50D8B173FC3C876FE669AFAC7DBA189E3B7784FCB38B52D10CA444FA
4A535CEF4CCE76FA43F6B1B1A7F0A7B404EFEE1DD041AA4A2A0BEDB156982C16
14ECB5D7E58CFD6098B51768F2BEFD726627666734C04E3B30B1468157175133
953FB485AEBB55BF5157FD093A534D94483A5CC1D9BD76C875B502DBCCDBD61C
97910B766B0D3B575C2163F6550C5D457582E9A085A8A5208EBEC18B98A4E619
D7238C02844AC734A6F09C7FEA6FDCD010DB671C74B2620D742600215355BD24
CFA4D684C5F18CE7D241DC36296D80E33DAA0C3CD5C41037CCE0F43CAB3A708D
2BE2CA09707DBAC4DE9C02A7705186B6BA5683E1D36B561C15452646A34A60B0
91FF098A83489DCEF5FBE8F48CE28F36A910C7D3E55F65BF26AB7D792354E12E
479DCB4C2758ABE4A39927BFEF119F8A1E24F2CBE92362BB6575121657B9DD87
A24E8941B14B7A9B55FF7D9AD2C3AADFA06AAC62F0DDBBF6309D57EC7974A354
10F4F45D37889376D26BEE7E47D8FF1B83A128212B8133130D2E3C72B57B3911
027315D022A847254F4826108B3D1B42DEA240D1529304E88F98DD7EE1197D04
8169B709385B88D9EEFDB284EEDDF178F2463AFE517B1B8C3E9BFC7C9CC7BC8A
B7A3F3DBEB066F94CC5E45F8BD0C9197E24995B1958620FFA07927F4FA594B7A
66194335C06A0069B6D10152358B9B02235DE926D229CA1B913B6C417E0927EE
D9FC86F22737891913D17F3E59108C55023BDFE6F4244465D63C14BB2F49DF39
13DEB54B46B8D3F5390F15B82D054235A9FBAB994124D913EB065588D33CB657
76496B4D31E8D6D5E8FA1AE5CA50D8A6CECEF3CE97AD172C65F7EB72717C91A7
285B56E23FFBB734560C09EE3512AD50D5AF91E1376AE7BF7BE43085D78A786B
1A04B645ABA49216E29C846205E522DDF1CE250F72D21E78A9A853BE474ACE3E
01C310714D3DD291F5D1D2211C58D87BF089EB69C07BCBE3A8618765F6AE4E19
80318E7EF266A26F5D12FA5ADF74434F603DDB68D3664187597F5ECBDCAE69E0
8F1BFE1DDB1815D29E4A3BDAD6EF3FFD5211315A7926538D103B0988F3E22A67
79CFAAEA610BD2B3818E7FA41C37C3A3F2189D93530FC449CF9FA7D4EA6464FD
CD31A643DD71082778BA78108955E36F8118918F97C7BBB94027FDCE0821CC7B
5EA3766FDADB571739092A475D2AFC36194FF80762A0270FC9A4912ACDB47AEC
E3CB1ABD4E08E64803EEF8F7EFFA193E2BE3E1793DECFF54E6697425A726B7CA
B06A991C26358027355372A3138D4968B83C661393ED106CF5C5BD2F44C8D37E
90F263A412B693CFE3EF06990857E912EE340840EBC0A4FAE72F75566F71D14D
714B49AA4BB84DAD5C8700A965F9970D7BC599117D8727EC6E0C470750BFCA65
B9ABD3AA4631A49A576EC7FC91FDB4F0A407E679147A7476DAE2FC89E4A19287
001E2393B6EFDE32C4CCD417E875D905AB042E09C3720C90119121DA941DBDD7
8F7634C7F853A7FB637A691439047FD0BAFA91E0B859F8A683E0C14003FA06C8
8BDD8392F5E15982D4E80CF68C59C644E6A3BB7CA5AC8EFC9C9BDC7C81F90447
A31981FC31AA81BAC01ACA510605270065387BE8E85B7916A388D24A5FFF7C1F
A5870234E368DEF3425C7839991EB56511B0450D2E18F48D633E55A4E8041B1A
13FD2FA9BF9723180AF667018D820E1C9CD3D84314D9394E0926B22BDBEC766B
B61E565912232BE9D958122947DBA5AC315C68E71CA821C65995B9DD072CD64C
3B0661CC493D6599CCEC3BCC994CE1FD7A02F465D1AD4D81439B423879906C1A
517F86D2C62BD779D9E64F181C254A122DEF616B104C5804E7FDC99E42FFFA74
51933938E0801F49E9718A75DFFFC771D68C11C8EF4951DF64A4B7301A834327
A3FF23A20D390C3EBFD7DEC7B8CC8EE6BBB6DE5E0BEC400A62767BDEF178B167
49E20A667955E95FDBA7AB5C630904390706CF1AD9DEC9E6349EC197F3E608D2
24AAB02F14679B3B19607730C12E67BEA5265F74C932FC4225129C65CF388ADD
2D044CC0005D4270445BA9253FAC9BE9F612EC537C97156C6551F97BAFDC8972
54CB7B8BCF2CA6C2E6637872F659C641D16B085D8400FFFBB92A8ECB72DD8243
4E32E81F9AAB71783B16A4DF95ADEED8929F602D6DAFA3909E909D699C1FA84E
707963C88D594B912C3B5BED51E6E688FC98C2839CE65C2DDECD3D907D64BB5D
DC308B4B5BFB4715B7E2457FBA3A994ADDCF71868BA680EB9980CA3AF8312E43
1EC9BC7D2FF0116EE37E100BAC87F8671AACC34F3E7E279FCECD3C494D464468
BFA8C2EA40E319260D8DF961B469BE5C0641EEB1C2B23AD6C1B72058DE679CE8
C7F8B077C2D91EFD5066E1C35CF9E822038086DEFE5936CE43FE194FDA2BE65F
ABBD89A939A0B9E63F46D971A023FA41A2E79E0DF323457D3CAF4B756A92460F
8268D4AAEB2DA6827C836335CB239EF9D2771EEFF70DD07274BDCA3C09C19EA2
415E2A0F0A30C13DC2A70A37F7C830D983DBC639B5DE09354C2D51A232278D13
574FC2C5BA968291864CD7363B65AB012522EE2F88B276E5A258E67366D5C056
828B853541276A50A7E49FD4E764B326742998E844D56BB0DA8147804B50CDA7
BBAD5C077185D82E9EC3074BAF6C12C80E4D9A885043E4F830DFD5414040AA67
446452B191AE01721DBA4BB4CC54F9C49B23798C2F01C8AEE0E4090830BF2828
C1F79C7968444F0DB581FBFACA961F03D1762A8E0AC324DEB5610EE4B01E8200
1ADE6BAC3A3A2CF9A3E410D469A7844C5172F36284F63F199B1E265B3DF29C68
F323E4BEB6A318AB45F6ED77BEC9CAF1C6DB55E8EAC789CC0B069256D1475689
8AF4114B94CDF5E8DF9EA935CC63D3DE38E5F91DC0EF38A0E0691CBC11F8FEC1
18F0FC23C1468F521DE231BAEEBE739FFA00B9C7874C114F41ED8890F4DA751D
B19FF9809B322A29DB6A06A99D3433B4CC1ADE9CBEE49A64845BDB364BC3C879
4BDB03D72A576504D777A5BB17D9A2C5311CA723188D829E88C77DAE0EC40A5B
C9192DA91A15DF82CB5F80C25CA411C6FA2DABE2F1A817C538EA7D410D1A7C63
1CE1221843E18E2BE093228678586D274EC67FA6ECA1514A418F55FDD935047D
1D412E28A933A933830B40EA1AB82E0E58CBDA9644FF0D294153C5A340C84FEF
FAE176853B9EC7DEE2AF8A30E8368111886F604C820B390D8525FD5B9C0A32F7
49D69F1448EAA347734E9C0D8FE2745A2F379526106A305B63622FC22656FA5D
5336F629C88E6C168D3636E4E4FD2663E6DE20CBBF9DB998827FD15EA8B6DD3A
E6D85C32AF4018D6337941E9F98E114F44E046627E381FC2A5DC720C53EF4564
EF6D86643A2FA07937894833467C0DA4A116B76D3A49515ACED0B6ABDBB69503
1B720133712788FED0EEAF4598557AC95444525EE89CBFE4DF60BA3216BD061B
4A49CD32A2FC7D4B4D2AD7902CEB4D2B531967C80757DD4F5BD046BD8990CA3F
399B6C371950D448D29B705C9CDA5A5E946CBD3580AEE751A70A0EA846656FFC
9A5C8FCDB7F4CCD34EAF775CA29A7E732AE0E5736BDD494498A95D9C33AC9A8A
395AF413C986EA9EEDD20DD0A499A1D511F8B76B6C20AFAD9B94D7D86D5F6AFD
4335810674DC2BA2EF7AA609AFC1CDB948F288A80ABC9664840D9C42E15EFB9B
17F2D3ABC7687DFFACCEB68940D7E73D6F6FD74CADC12D2B0A1736ADCCF303B4
FC8F503DE04BEBF23CC2299F6C600703E5D88D4E585889CBF1E7EF9C2181C9DC
66783428DE91300841D09BC5C1E3319918EEBCFF88C0DE48E79E2DF446F7AAC8
21028D8240697E774F912847080A556E27A633AE5597E4C59DD6682A8DEE24B2
6919701A788CE86923C8A909DD9FA5C4A9DC4398695F327688403C3A5A33C8C4
B63DC1C10E038B66C6CE38A97DA7BD33126ABD5EBEBDCA4C58DF7527F82404A3
6AF90A9C4CA613554CA0A0FC2BC1A3349C0C30C13D92E387A9A5903F3D9EFBD1
31E1691F74AF35B119A61B68374AD028953FE4ACA331175F4677BEB9684AF30E
77DB2EAE3A89AE26C91AC0FA666F6A7388E3464A38D478B286691EFD996D67D1
9A33AED2E2A8FEEAD0D313C80DB078B1EDC023E75AD49BA7AE5154DBA9F8C477
B49CCAD8F837F3214F4F214DFD133F8192E19652A3EC18380FEC9C1246F5111D
A9D838A1DD3B19DAB32EFCD86DFD1D18D83AFC1BA88831D9B9B12935EB59B55F
8D3825FA2B2AE666C27F082A471246E8884A7835ECC744B40C220690BD705474
E6FDC8720F72167FF6410E6217B53758A3B5480C9045F9AB5702C05640EACE6C
261301FF1873826941E9AAD93648ED07D54A9C26A33BC9ACF98B7675CA5228CC
EFDDC722FECF62C992A80D077F984A9B4B7467486C670C50DF969F3B5FCF2471
A01D087FD6F231B461AF42118BAE4628F7B28FCD2631D5548FC8DF1C241030B6
BD0E3687052DB96C0A341D55B0F29D177321F9F6B178B36E5C41F961B828E38E
43713BA46516D6C3366FD93713226D0A59DB0C11E5C12122251A3968A2DFB172
885F1F428E3CCE073D8A00670B60B92ABD1BF47613047EAB43652597C9FD7A0D
36AFA14969834FEE29D759678998E81CCB7F7491B037098BC9A9C8A9E8D7266E
E4E6568B238FD1149CA87FDA29F0DBDD7BFBBE8A70B0B58FA824C12CF089B2CF
807023A9F323D6297ED3FEBC26B0E38EEE5BA19AC90CB1C2C8F8C4831A048117
5FBF5284F734FB454F1FD4C82219A4CC44D808180940DF9F42079893DE9B80BB
7674820302640C7920F1AA1B90E745FE2D7618C621F74CBFBAD6629D163E4FC5
D72616C2BB65D7B1E511CB2A7E4702A724806AA3FA83A9DE34DB07F3D6D3356D
79AD695DF3A87503E17F7BB24C240C85FBEB02D4670356928C24D1A37A5F5E93
72EA79D1114267C7B7CF6B38273C9A32A0B537A8857393353E4608296ED66741
FCBB3037BB6E9EC00AF2A4A9A479C8C685EAF3C931CD104833D475784D6F75A1
01F254BEEA9DD5344D590B94053BC42DBB0587FCC0F4B9980725277A30194C1A
FDAD087B2E4305ACB33B93DF44F86D3827FDC9D606DE7045E897F2439AF13307
2D46A27B87AB994E243A459078816796D33404D241E14CEBF60687848E181378
0529E8CDD832E1FACA71BD7759CF4CC04ED9830DB4D7D91EB17F91087BB3C6E2
42EFE6333A6E5572D85CC460DA5FF8BA92E6B7E141D48C8DFBCD7062D7EEED6E
BE7FE3F684296DAE14CF7BAFD0CE9B82592C65104F6D0B366D21AB85643B0A0B
9632AD80924E7FBE024354ED496F1295B390F4D308775E217D8E5EA9E9A90875
5D342E5982847A2804A06EA84070B69B2F9918EE2665D1C81AE6E8DDA6895AA9
E8C2DFDA48173E2B6A02746B0C321D993DF752B5FFF78E6A4672FF09B0AB096B
ED4EC094DFDB208F9A000903A09C853546436FD525D92FC9901FE996B2ACFA19
8922B58D11F71DEB482CFC268C78E1CB98ED659EB9C4DE8A0AD9AFEB06E4A4AA
E9DF213FCCA2E69998D69F343C3467241EA4BC50AA0AF65D3ABABB8B5AE27333
338EB763939A9091A50CBAF55DE1A1BF3B54AC4C09349BF7996C3B117DE9425D
BEF583884A1B78EAB6FB3A62AABB06A7870EBDA9D2682AE194CCE41DDC9F9FEC
EAF8512227297DF7D3B3B822C9B89AE54E870587D3F535772A87A49751BD775E
68BBF8A9EB633722426BB52479EA913C1F9EA28880EF74E1C21A97CB989B7531
D45F08317EBC737A89099CDFF8B3AF4475DC8328F78060BA4331210CF59146C1
41F6C692EBD82678E9888781B3AE471467FCCF9CD34014780A91EB0225A7E13C
D8BED73F7A9742EC7D4CC8D10EBB6ED3D5064311E6091D4D44B6D909714318F9
6200230DD1C0CE0B54A112DFE1FA39A4C1333D7CF16B0AB079A6DFAA0C4CBD61
95A73580CA6BBE286569A5377111F2686BCE6636A0BD007D589F0F820105BB7C
FC939516DF00C85517E2AB919E04F983D35082CF215E3B9D65E31AE060B3B53A
A6378D8CA6351E2E0A4227FA756DE4E8149A78A918C82815351AA2920E22B004
DDC927300AD74AF637E373925DAC52C3DC9E36DA583CFEC62C76A45F93440664
2BE1AE8ECE2BEF0A601A944E02CB6DFD5D6F87C6050515CAD572114C1C7CA972
E380341CAAC7AA94D3A4EAB1B8FE9D826023072AE3395CC19B979750176D781B
A37DF879AFEA6AAF2EA378A3C3D804E1C1F36C30C661A1B8716652071D965D21
ECE016B3D9473BD3B8B69C0698D63EE8732C4E34A1016488B22F521D1F488CEE
152DF90C93805A2E573D069E0E251937AD14B0EFC848D5F63EB55E5DEA15DB54
493E387C7116A4297255FD93F765F05B827A6A84273A8BB35347F19043C7E618
1572721F4FF76CC5B2035B5FA5BD6D0F4E85EF8687EC71F8791F382275F0C4E4
4B39CE5265CE45A76A163849284E2E827A9C217AE7B60BC4A575FA855DE2D0CF
B8AA39A27925F116D180F631970D8E961C0BEB9AD3F5D87EF76CA3A6B6B062FC
76DC831D334E9E419A5B7A0C017BC9DB70F3633FB174DA25396CBC14B6D619AF
7C31441EA264F9F91F3D7457A2BAF74DA606D7E0721D9B288A181F1AF62CDA62
E32940DB52D05175DDB0CF6D204DDFB9F37CB90A1E9A9D8D237C0DA766F8D670
3E28D6F65D91D333A2CFC3FF359CC8664F1A6603687704EE16B16892013EE184
655B54E82F9389C435100BC313FA9BB8420085FC242BA22DE7F37A5639CBD91D
4C81C8BDEBD3A3B11086618044B4EE3D3ECFFA56DB1390AFC9438B0B46A283EE
09BBD61FF65A82401F25574BC9C2B00417EFFC32AB1CFBE0F946823CD090034E
0BE08A92A1494DB73ACC8F3C4DAF50E5FBBB013110DECFA67C30DB1E99917574
D719C815F47BD26AEC0C7A2E51D2DEEF0C43D09BD8CC187D349B7BB8E900E900
A7DEAD963C9FB904C0AE7054C9E9DE49E5BC7F727BD3C814E17BEF73295B5DAE
FA8537FB139025936564343558DBC2DD57FE5621D751BAD5B0BA407A1B516C23
AA0A5D28FCEACB79E7E3128FA2A65B58FE5293A319E8E20E20D2A4B82A699B52
27D55B3313D59DB2883387C7566AD6800CBAD6E81AC3E78750E6C325FA20CEA7
3FE1B5247D4CBE0E6F46AE4CCC9192E6B252F055CFE15DBF109F8D2A9F3C429F
61204A04C1F6275A7B78932CF14DA5552F34D809E1A38F65E5BD0087BFA2F613
298B573A09692B6FDC121DE3D358616A1F48F459563D2F9AABB995A662B2143A
4382BB418528E8E37C3DF2202FBD00592C2FF2A519D7B88222EBF0BC76893DA1
8FB47F9F16111EAC8BFB3F1F51421F247B73285AFDBEC6DF2B7679DCDC16C334
B98587870140FC3F70F916FA4A5032D284011B7B4DE933EAF370C41F6C15C02D
1A87E9AFF0EACCA70DFCD48D06C9CD3F680906CB38D0C557EC97E8BBB5099847
32751C6D635BEE91D4343CD6E7FE7BA6DD3A932AD1D956F08EE45F50B0B60825
9CC8856259809E138B5F523AEF5969C5926C8E5B9408D96222D76875DE653C40
EC7B16CECEF81A056D53D0A0EE14BBA19BDA8554CFBA4048F2AF61C4FB4DFD0E
C66A55F9F6A1FB1D5544E5F67B7FA14894599394F8D3B10B884560FE6498A9B0
BE6D0131B866B55C6089AC5D30AC881D8637EAE8FFFD8519CFF9545872E7A669
C64F4E95209B6538EABF82EB7E4B29B15ECBB4C3B44F259BB97B6B462A5F38E7
A3A97D8EA9FF59A92A9F72C1DC1F484009FC2160B3927E5C2E22D7AFB537D8D9
F3C673CD59E828384EE987DEDDF0727E311D760A1F9679054898B2D2537F14B8
887F576EAF9A0B2DEBEF403C63F656006761E312A216856A0BD403196C201F34
CB202C354161DD9DE4D68A8BCE2D5B57A47A2C01137E1E992023355EC8662A69
49F25917F353C9AF08B538BFB95767C942712119F26AA23FBCB784BE01D058FD
C990C3DE8AB8C59B52FF5723D3C8E3378EC4449BCFC1B3B3435C62FC9D6680AC
332FD441BA7C8620A52EC3A8AB37980A8F138B3C9AF5DC169BF13C56EB0E8BC4
1368FA1B977789708DB031DC4B574234077314978108B159818A7B0CEBAAB351
85C3E909126048BE4E89E32F2774ED6DB52FDF179D0C724F976D630DC6F2532E
C9AF54218EBF26C692EE37045CBFF62376C4762157704952C7F4E58935FB2458
70C16236B8759077826CF186D582DD972AFD9A8106ED1C5E7ED1AE5343E097C0
179857275768D47D508650B41E8B79C0C2431716D5E9C4273726DCB6C68815D8
6C6E7E21859EBD3BC85CDEB5213B4F0489CB380E270D031F0260B13760D80847
3EBA70D9F280C9CD217D762078DD3E5019A6CDCFEDCCFCE1A30D9E8FFA9D0AAF
D64EA6EB8BB85DEDEC0DC909B5CCE6AB211495222448DA97B7BF3340972F6EAF
AAAC55D15945B2E01F6E47C6C79E8591E07D49C82244079A9E06D1DBA4AA0C71
CFA918C05E72873C44390513F7D25384B0D1E385638A37380B74C663C3F2ADC2
36F49E1C268A14446CCFE5F973B650EA41E55F4077E6460AFBE37AC3236AE9AF
66587D0F3319143ED798348B9B4FE0E8C13F5F0A42CDBB9BE7D62774E609D7AC
E06BCA17934210C32A07C5BBE976434746A542BC851377AFC0C3726112DAEA78
4423AB9BD441C309D9350394BEFFA4FB08021BBCC99F9EA3E2D052E90F13A5F6
E8A3606D42EFBDAD7636185A5DC741BF099C42A262B579A37D35868ADF3B765F
31BD393F6E4ECFC5628DA918750549B20EAF9384BC1A09F9C53CB48133D94593
FAD925E2C2051E5C588B5B71AF3DBD903CFE3E056522C4A8E503537914886C7A
670B8D6834EA61BE9217C2C648DBDAA4A7DA565F2A8F6F1F784D07BB4869466A
A8088543F893BBBD19C4F19BA978B1CF72D20E91E30FDDEE7FD76FED0ACE1CAF
A59CA20F18140F32F2593D6863E7872C5EFFAF507DA09F3E72A9B12E19EB5D4A
4CC8923A944205374E9A76B9FD502B0CCEA4543ED13027D165D00BBAA8DCC804
49E197E345A6B9E0D6160BBB53F119A78D5CBFDF3CE870005977FC252EA4327D
2A9AC45852EF6435BCC52F2DCB56E4A805190319D424D2AE0F971E94C01CB172
C195AE429D7CCAA383A8317E6C564741D888FF31CB71FA5FF71638366DB365EB
8BA3152DEA46756881E6DC09A0A9E1D614C9FCA10A54D32B095322C9DB5ECAFF
E3D2EBD715960301C59F2CE0E6098A40986A5FD740C9D0986C34C0835F0A942E
3DA425D899B33FC49D0880447FEC13BC7E494DB86087B5639199ADEF2DE286AD
BB2EBB66CA1F239089AC534531ABE9FFC2486A7512D3F5099993B56CB6397BDD
FCF4F9EDF4DC2F532750234B9B7BE0BE1F2804F33EEA374F8F393B2383E55FDC
E02FFB4874A9CC36C9717DFA9B5FCF18891D5C095F3C5A0ABB6A2ECC1AC74068
E65966756D73A745E5FBBBB7FBDE5108352596411E62607A69F2BB837EE9CFD5
DBAC91EBD06B580C3A67A908C280FAA54AB045CF754C65189DC19D1B2C280C7B
0914F92F714B5D0F78C6909BD8F3C78C805400636AA8253B72618FE64F848121
3C04CDC2916ACFE714A2611602C5E8F683B45A9653B24873D53F8082CC9D54A1
D4834F96C303F5FAA30E9B627F56347D85A578F49A40C04DC707C8B7892DA8E0
3F79D062F4682DB04FD11B385F9799CF535E7193EE64ADD9FA0BD9837D99A001
3DC97F1729716C8D84E3BA51A75272EDDBE949D58AFC785D4F2A9B20668E4C6F
0734A18B8EA7B077B7ADBDDB15C5AA99EB2914D7DCA2301C489031EF0F0F712D
269120B0F0715EDB0FE7470CACB03E1B344E3B299B49B5A65638BE9F7F059053
198A656958AE4D4E17D3C92141E04184987F6A34A1FC75C8E69CBEBEFA210744
FB8027E8ECAF1BDF49C2F1D95273DE281D60DC4EF6E2668B6392C03BE4415BAD
8C4E9F366E53643C99321A702FA71DDB5C0BC7E0F7819110E6FEDED3D4FC7628
80B58F58A8F47F990308C7CA1FC658FA03284D68CB91DE641E7D66BF772D7CD0
E1275E30BE3FE2BC9CD49F901B8C842845C30C844307C6A4AAA30A5B3B359FBC
14ACE4E945A531FDD138538C0FD875F64714AFAA78835D2A0F8130FFECDA4CAD
7A0951B903F60F0CF522B8A559263DB696538C3707B39C1C2FBC20813145981A
E8C136C56044FB3FAA606D9029FD9604200678179C9648E92FC20FF3E62199F8
D3A94306A22CDBC265FD2D45DCDF108773E4E4F1F63BBFF536F9CFD841A9D8F9
FFD5D24A29416A6506EF7BE0D60FD9A4B69F4881D91A6595ECF80B930DCF4310
F498F1630194278A2835CE06FEA6FA67008E94F26909D2A34BCDC5FB11EEEDDF
4D67AB1B4F26E16256173888BFA685947A2F28A8B88D94BAFE7746840ED1EAA2
9FAA9DEB15ECD75987609F7001BC1921A8EDEAC8A3A8DCA71CF8598CAC9104D3
48990B838F5ED80E07F7EBB77738ED7BA85AA0328D2C67A141C57EEA14025D5B
55D41428AB05E5D4996D7CDD54C306C6979EE3B057DAD97AFE7312DEB6A7DCEC
536B2794D33221D5A8054C26F6870C0B6A5AAB00D437FD82A306E89760E703C2
27ABF707F7F15315550834DD42CD2C2624E407B03B6F6E382F5F3CC9CBCA9D10
FB0F08E1E50BDEF88B4836EAEED7E1E27105AB069B93C6DF73681993488D5B6F
48C199F2610098FDD4C483F917C30D28D29F66F1B2B03CE2E446D639C3224BCA
F794F931845EFC18DEEDE8AB134A3047D7C6AB5B8717A53DF6C22AD373203275
E65DAEA42686151FE74E2B0FB271AFF2FC4AA02184073EF9D9EAC6181161EECC
DF283ECD331CFF4DCFEFA8FF256134311CEB21E2ABC1034249A4ED8D51DE50E7
0451C079B2679A4623D3A138426141598F02AF36CFB59B308DF89E6D3F629BF4
749761E3D8A586DC6AC72EF77144BF5204C841A2EF2D938F5400A9BA0FB6FDDD
B9890C0537AA1B2978FEFEB23508260ACA4DCB1AE76946DAB2FC3E9907EE1DF8
0EB9078D5962655DB89D7AF216A69178A638B50B092B32ECEC7B13562AB9F6E3
9413C4071C3DB7C8276AC3D2C9F90606053146E3AC2F975A24FB27016EB79A26
45E0896E8A89C179D39DC6E1EACE4651D5E8429488E2FD0155B8DCE9816D5B8C
F1256954D69D907A0CA52B80E5CA58E18A3DD2502F218ACD426DD1849DC5F04F
CB5AA6CE692AFD4F5D04355DE453CDC320A39C12754A0FA6B626AF0424A02982
A8C8DE7204D3B6371B158C022888D96702DFD541B0C5BBDEA982C6DFE11EB30A
B44D8A79D4BC0BD1F4796E7159677CF27D170D709B602AE98F990380B32EC745
577A1BB7E812CDE64F898057DA16C6D7E6C9C06EE8E0E0531D360A83DB9C7EC2
E5EC721BD656BD71B901B23A28E34A0865131B82F06932EB2813B3012135C1E3
4E20620F55BD7C8143778AC68696195E23DF0FD8E5E7D4890A8D9DD49DE234E6
2A10DE99959C8357202BBE03B6BFCC591A41E9B98C7224C83E86FA5F48597239
77FFEFB6A529860D866EE64601753915832DD261AD2D769DC2207653D6FA66CE
1076E40848852FFCB5EF65416FAAE9A52041B4509DAA4FD71B63660135B42630
49786D41F1A088D63F9358C8FE0AC99FDDEBCE8079A15778AFDE507CFBEB754D
93591E3391BCC343A2BC49E40AB9DBA139C55513132AF4F448332D1460D2A6AB
1270E396ED17AFD7C842C338052E054E9EF791CE1CE69198B5535207B12C9054
63BF3D03E79941A9F7CEED317F82BDF414C1748F12E48C5BDDF8526C89C0EBC5
0AEDA85DF2437760B4B47B24080F9BFF5751254DC628230B7F036583356A0808
427F80445F9D773FE763A6A439DCCC6CAFB05F18890564F82F8BD0FABAD22F15
A131E4551F172A23D420B7FBAE095F429006E84EB6C309521FD02B5492A2E009
494483AC4E27D95829C5F88F047AF1BFD994DDB862C1ED707FCC9F36BF3F3CA2
87A2164DD283763BE72EEACCCB67EBE19AB60B82FB64243A0D09C34CC45FE78F
6924D04AFD06CDCA6BF0875795310552E5E9E3E9F3C23E80D5D4E87E279F1748
05133647DE630EE61538606F0CDF820675524C7A984D95CD44E97FABFADC1EAC
5B9195BED023580949B7A95DB70C81FDE68A30963338A9685807CBDB20999CA7
FD7EC977DEB97259736989EC160E583C30C1A74AD62049359E9B34100991474C
3ACBD6FA00E79BB09C795FAAF63F970F65259AB9605CC68535A2AF996A126999
A96C360463B489BD73FADBC50A0FF1125DDCAEED37C5C2CD133B50A00589439C
2CE8B9529EA2859C40348C4527B440F08DE895F3CC758FBE4FA6858811889B50
0498980C9CAC6B9DD7A7CEE8D3864CAA34774F7AD077791302E125DCF728DD5B
37901C2098D5AB2C012BCEA66592586A61CD64DE612AD80A03D3BA3D12A6C9DC
012E37C2FCFD14DFE226070C7DE7219A2C797ECD3829DE725167A733F1BBC08D
C0CCFC3CAA6231F599A26B25EC01125FC4E1ACC048F82AC164ED0C5677707772
3491F65D2C5A2D5D76B712D42729D77DF6B670D5FF2BE4EDCAB9DA8936E6F9A1
4E2AE1BB0B2A08D27DDE596A6E4DCBD0821BF32AE726E89B9C984E52FA1A6A15
360A3DFBF3BE4BEFFDA4BCE933B192CAAC2CB3AD413F12DE04257883E0A5587C
4142E6835CD4F708906D9F276CB772EEF0DBCCA7568F5CF7D101DAC3A9E804D2
58404B9BAF9698E421615062CDACE59438DB8B0D784730A60C761B1658F217BA
AC94B364F34E51923829B397B402451897EFB58D4B09EA0263E69CCE4F4651BE
64A65D3CB12757C24DF3B712A9B15A312539F52C444932F7B5F476B0B535A2B3
9086D7DCD4441044B742285AE44B5109A928E504963041DEEFA3835D5844C6D1
B80E2F01CE66B82D66C6C92CBA858AB4374270AC663B263AB99FC45B385DA123
AA53D643214B6D84F0757D21087F799BE7B37674295E00731B5D17179E8DDF60
B5328099C95C3116B12FFECB493B6B04B98E690147C06694727E72B5EE56D271
7F972721E6FA86CAE23708B5B76CF545CFEE841C423247E830D6560C21511BC3
DAC9B682DBE08180665B1F5FAA5F46696DA6F3E311A3321BE7A225F3777DED53
321381FB94B320CA35F718B51D83CDECA67133F187A2F30EC483B186628FA74D
3F4134DACE0F226AAB7B65605051C001944771838231BEDE38A0CC9DBCE0BB56
ECB5B90D05D6E41893C449AE565CB9CE246FE5D4F7B7DE6B52E6721439EA6ACD
2DAF90B1A2EAA41E904DCB2CFBE5A398063FF9873E1C378D136240FF87389063
6CE5F628AB56F83472C6E2ACEDD643A3E131BDE8DAD42163EFE2FBDA177AD687
AB2DD0AF61B281C98E88DF2F3B539E4C1DA5946752DCFEFB0D681D52CFC6934E
969F8A6D7D0E3F20EEACFD292A286E80C774F64A01164FA68174BB3091B40510
EDE5031341EEAB331DBEE83F3F1F5640FE45E155F943753057CD9932031157B7
EC902C29742B17D5B8A941130F0EFC89056D25863772AD3B62F70EF8D9CD7415
91A0772922F41ACD9599CAA2E0F2B99FA02B68DD6D03EB2DCCCFA292E599FDE8
0724AAABD24316C120860D31B31488256E195687CF0B326DF7CDD3DC07212F5E
E583055180A91CB0
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099151 1000 600 600 (CorrigesTechno.dvi)
@start /Fb 57[55 9[55 22[55 1[55 163[{}4 76.3802 /Fourier-Math-Symbols
rf /Fc 4[46 17[39 39 38 6[40 22[46 79[39 37 1[38 46 26
33 30 45 46 44 47 70 21 2[22 46 40 24 39 46 38 46 40
10[48 2[41 49 1[46 58 1[72 43 2[27 4[60 52 3[30 4[20
40 40 40 40 40 40 40 40 40 40 1[20 1[20 2[27 27 21 1[64
34[47 2[{ TeXBase1Encoding ReEncodeFont }57 76.3802 /Utopia-Regular
rf /Fd 22[40 112[40 3[28 1[34 1[47 45 49 1[24 2[24 3[40
1[38 1[42 16[50 1[56 8[48 2[52 15[43 43 2[21 46[{
 TeXBase1Encoding ReEncodeFont }19 76.3802 /Utopia-Bold
rf /Fe 22[57 57 115[41 49 48 1[68 64 70 104 34 2[35 3[57
67 1[67 60 12[69 3[71 30[62 49[{ TeXBase1Encoding ReEncodeFont }18
109.987 /Utopia-Bold rf /Ff 22[47 112[45 4[40 36 2[53
5[27 1[48 1[47 55 45 31[63 67[{ TeXBase1Encoding ReEncodeFont }11
91.6562 /Utopia-Regular rf /Fg 22[68 68 81[66 32[80 45
58 51 78 1[76 82 122 37 2[38 80 69 1[68 1[65 1[69 16[79
2[125 77[{ TeXBase1Encoding ReEncodeFont }20 131.985
/Utopia-Regular rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: Letter
/setpagedevice where
{ pop << /PageSize [612 792] >> setpagedevice }
{ /letter where { pop letter } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref)/Author ()/Keywords () /DOCINFO pdfmark end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
-254 -561 a
SDict begin H.S end
 -254 -561 a -254 -561 a
SDict begin H.R end
 -254 -561 a -254
-561 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 -254 -561 a Black 0 TeXcolorgray Black 0 TeXcolorgray
-246 -246 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -246 -246 a -246 -246 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -246 -246 a -246
-246 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -246 -246 a -246 -246 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -246 -246 a -246 -246
a
SDict begin [/Count -0/Dest (section.1) cvn/Title (Proportionnalit\351)
/OUT pdfmark end
 -246 -246 a -246 -246 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 -246 -246 a -246 -246 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 -246
-246 a -246 -246 a
SDict begin H.S end
 -246 -246 a -246 -246 a
SDict begin 12 H.A end
 -246 -246
a -246 -246 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 -246 -246 a 0 TeXcolorgray 0 TeXcolorgray
700 166 a Fg(M)n(ath\351matiques)30 b(\226)g(P)n(r)m(emi\350r)m(e)h
(technologique)1496 577 y Ff(C)o(orr)q(ig\351s)18 b(des)j(exer)n(cices)
-246 937 y
SDict begin H.S end
 -246 937 a -246 937 a
SDict begin 18 H.A end
 -246 937 a -246 937
a
SDict begin [/View [/XYZ H.V]/Dest (section*.1) cvn /DEST pdfmark end
 -246 937 a Fe(T)-10 b(able)22 b(des)h(mati\350r)n(es)p
0 0 1 TeXcolorrgb -246 1120 a
SDict begin H.S end
 -246 1120 a Fd(1)67 b(P)o(ropor)q
(tionnalit\351)472 1120 y
SDict begin 12 H.L end
 472 1120 a 472 1120 a
SDict begin [/Subtype /Link/Dest (section.1) cvn/H /I/Border [0 0 0]BorderArrayPatch/Color
[1 0 0] H.B /ANN pdfmark end
 472 1120
a 0 TeXcolorgray 3631 w Fd(2)p 0 TeXcolorgray 1930 5895
a Fc(1)p 0 TeXcolorgray eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
-254 -561 a
SDict begin H.S end
 -254 -561 a -254 -561 a
SDict begin H.R end
 -254 -561 a -254
-561 a
SDict begin [/View [/XYZ H.V]/Dest (page.2) cvn /DEST pdfmark end
 -254 -561 a 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
-246 -246 a
SDict begin H.S end
 -246 -246 a -246 -246 a
SDict begin 12 H.A end
 -246 -246 a -246
-246 a
SDict begin [/View [/XYZ H.V]/Dest (section.1) cvn /DEST pdfmark end
 -246 -246 a 83 x Fe(1)105 b(P)o(r)o(opor)q(tionnalit\351)-246
-54 y
SDict begin H.S end
 -246 -54 a -246 -54 a
SDict begin 12 H.A end
 -246 -54 a -246 -54 a
SDict begin [/View [/XYZ H.V]/Dest (exo.1) cvn /DEST pdfmark end
 -246
-54 a -246 -69 a
SDict begin H.S end
 -246 -69 a -246 -69 a
SDict begin 12 H.A end
 -246 -69 a -246
-69 a
SDict begin [/View [/XYZ H.V]/Dest (Item.1) cvn /DEST pdfmark end
 -246 -69 a 0 TeXcolorgray 90 x Fd(Ex)o(er)o(cice)14
b(1)p 0 TeXcolorgray 0 TeXcolorgray 147 w Fc(1.)p 0 TeXcolorgray
42 w(On)j(compl\350te)i(un)f(tableau)g(de)f(propor)q(tionnalit\351)i(:)
p 0 TeXcolorgray 0 TeXcolorgray 1425 108 1258 4 v 1425
208 4 100 v 1478 178 a(\311l\350ves)p 2001 208 V 360
w(40)p 2340 208 V 268 w(?)p 2679 208 V 1425 211 1258
4 v 1425 311 4 100 v 1478 281 a(P)n(our)o(centage)p 2001
311 V 144 w(100)p 2340 311 V 219 w(70)p 2679 311 V 1425
314 1258 4 v -38 438 a(Il)e(y)f(a)i(40)10 b Fb(\243)g
Fc(70)g Fb(\245)g Fc(100)18 b Fb(\306)c Fc(28)k(gar)o(\347ons)f(dans)g
(la)h(classe)o(.)-246 471 y
SDict begin H.S end
 -246 471 a -246 471 a
SDict begin 12 H.A end
 -246
471 a -246 471 a
SDict begin [/View [/XYZ H.V]/Dest (Item.2) cvn /DEST pdfmark end
 -246 471 a 0 TeXcolorgray -141 567 a
Fc(2.)p 0 TeXcolorgray 43 w(On)f(compl\350te)i(un)f(tableau)g(de)f
(propor)q(tionnalit\351)i(:)p 0 TeXcolorgray 0 TeXcolorgray
1425 654 1258 4 v 1425 753 4 100 v 1478 724 a(M)o(ar)q(ins)p
2001 753 V 332 w(1)12 b(760)p 2340 753 V 167 w(1)g(046)p
2679 753 V 1425 757 1258 4 v 1425 856 4 100 v 1478 826
a(P)n(our)o(centage)p 2001 856 V 144 w(100)p 2340 856
V 228 w(?)p 2679 856 V 1425 860 1258 4 v -38 983 a(1)c(046)i
Fb(\243)g Fc(100)g Fb(\245)g Fc(1)e(760)20 b Fb(\274)15
b Fc(59,)8 b(43,)20 b(donc)d(environ)h(59,43)h(\045)e(des)h(mar)q(ins)f
(sont)h(tomb\351s)h(malades)o(.)-38 1147 y Fd(N.B.)f
Fc(On)e(fait)h(le)g(calcul)f(et,)h(seulement)i(apr\350s)o(,)f(on)e
(\351cr)q(it)g(la)h(r\351ponse)g(avec)g(le)f(symbole)h(\045.)g(R)o
(appelons)h(\340)e(cette)i(occasion)e(la)h(signi\002cation)-38
1247 y(de)g(59,43)j(\045)d(:)1604 1373 y(59,)8 b(43)19
b(\045)c Fb(\306)1969 1317 y Fc(59,)8 b(43)p 1969 1354
191 5 v 2003 1430 a(100)2183 1373 y Fb(\306)15 b Fc(0,)8
b(5943.)-38 1596 y(Donc)17 b(dir)o(e)f(que)i(59,43)i(\045)d(des)g(mar)q
(ins)h(sont)g(tomb\351s)g(malades)o(,)h(c)n('est)f(dir)o(e)f(que)g(la)h
(propor)q(tion)f(de)h(malades)g(est)3401 1540 y(59,)8
b(43)p 3401 1577 V 3435 1653 a(100)3601 1596 y(.)-246
1668 y
SDict begin H.S end
 -246 1668 a -246 1668 a
SDict begin 12 H.A end
 -246 1668 a -246 1668
a
SDict begin [/View [/XYZ H.V]/Dest (Item.3) cvn /DEST pdfmark end
 -246 1668 a 0 TeXcolorgray -141 1748 a Fc(3.)p 0 TeXcolorgray
43 w(Le)22 b(fait)h(que)f(la)h(bouteille)g(soit)g(titr\351e)g(\340)e
(12)i(\045)f(vol.)h(signi\002e)f(qu)n('elle)h(contient)h(12)e(\045)g(d)
n('alcool)h(pur)-5 b(.)23 b(On)e(compl\350te)j(donc)e(un)g(tableau)h
(de)-38 1848 y(propor)q(tionnalit\351)c(:)p 0 TeXcolorgray
0 TeXcolorgray 1366 1935 1376 4 v 1366 2035 4 100 v 1419
2005 a(V)-5 b(olume)19 b(\(en)f(mL\))p 2060 2035 V 141
w(500)p 2399 2035 V 228 w(?)p 2738 2035 V 1366 2038 1376
4 v 1366 2138 4 100 v 1419 2108 a(P)n(our)o(centage)p
2060 2138 V 262 w(100)p 2399 2138 V 219 w(12)p 2738 2138
V 1366 2141 1376 4 v -38 2265 a(La)f(bouteille)i(contient)g(500)10
b Fb(\243)g Fc(12)g Fb(\245)g Fc(100)19 b Fb(\306)14
b Fc(60)k(mL)g(d)n('alcool)g(pur)-5 b(.)-246 2296 y
SDict begin H.S end
 -246
2296 a -246 2296 a
SDict begin 12 H.A end
 -246 2296 a -246 2296 a
SDict begin [/View [/XYZ H.V]/Dest (Item.4) cvn /DEST pdfmark end
 -246 2296
a 0 TeXcolorgray -141 2393 a Fc(4.)p 0 TeXcolorgray 43
w(S)n(ur)18 b(100)g(personnes)h(de)e(l)o('entr)o(epr)q(ise)o(,)i(il)f
(y)f(a)g(56)h(hommes)o(.)-38 2508 y(25)g(\045)f(d)n('entr)o(e)h(eux)g
(fument,)h(ce)e(qui)h(r)o(epr\351sente)1566 2690 y(25)10
b Fb(\243)g Fc(56)g Fb(\245)g Fc(100)18 b Fb(\306)d Fc(14)j(personnes)
-38 2873 y(\(on)f(peut)i(bien)e(s\373r)h(fair)o(e)f(un)h(tableau)g(de)f
(propor)q(tionnalit\351)h(pour)g(obtenir)g(cette)g(r\351ponse\).)-38
2987 y(C)o(onclusion)h(:)f(les)g(hommes)h(fumeurs)g(r)o(epr\351sentent)
g(14)f(\045)f(du)g(personnel)i(de)e(l)o('entr)o(epr)q(ise)o(.)p
0 TeXcolorgray 1930 5895 a(2)p 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
